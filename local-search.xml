<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>力扣3721. 最长平衡子数组 II</title>
    <link href="/2026/02/11/%E5%8A%9B%E6%89%A33721-%E6%9C%80%E9%95%BF%E5%B9%B3%E8%A1%A1%E5%AD%90%E6%95%B0%E7%BB%84-II/"/>
    <url>/2026/02/11/%E5%8A%9B%E6%89%A33721-%E6%9C%80%E9%95%BF%E5%B9%B3%E8%A1%A1%E5%AD%90%E6%95%B0%E7%BB%84-II/</url>
    
    <content type="html"><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给你一个整数数组 $nums$。如果子数组中 <strong>不同偶数</strong> 的数量等于 <strong>不同奇数</strong> 的数量，则称该 <strong>子数组</strong> 是 <strong>平衡的</strong>。返回 <strong>最长</strong> 平衡子数组的长度。<strong>子数组</strong> 是数组中连续且 <strong>非空</strong> 的一段元素序列。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>构造数组 $a$，将 $nums$ 区间内 <strong>同一偶数最后一次出现</strong> 记为 $a[i]&#x3D;-1$，区间内 <strong>同一奇数最后一次出现</strong> 记为 $a[i]&#x3D;1$，其它位置记为 $a[i]&#x3D;0$，则问题转换为寻找最长的和为 $0$ 的 $a[l..r]$。我们就可以枚举 $i$，将 $a[i]$ 逐个纳入考虑并更新前缀和，寻找第一个 $sum[j]&#x3D;sum[i]$ 的 $j$，用 $i-j$ 更新答案。</p><p>现在存在两个问题：</p><ol><li>如何更新前缀和，新加入的 $nums[i]&#x3D;nums[j]$ 会导致 $a[j]$ 变成 $0$，而 $a[i]$ 变成 $1$ 或 $-1$；</li><li>如何找到第一个 $sum[j]&#x3D;sum[i]$。</li></ol><p>注意到这两个操作都可以用线段树解决。具体的说，对于第一个问题，我们不妨用一个哈希表记录每个数字最后一次出现的位置，在加入 $nums[i]$ 时首先检查：</p><ul><li>如果是第一次出现，则 $sum[i..n]$ 区间加 $1$ 或 $-1$；</li><li>如果不是第一次出现，上一次出现在 $nums[j]$，则 $sum[j..n]$ 区间减 $1$ 或 $-1$（撤销上次操作），$sum[i..n]$ 区间加 $1$ 或 $-1$。</li></ul><p>而区间加用线段树很好实现。第二个问题，注意到前缀和 $sum$ 相邻位置的变化量的绝对值 $\le 1$，根据 <strong>离散介值定理</strong>，给定区间 $[l,r]$ 的 $\min, \max$ 值，只要 $target\in [\min, \max]$ 则一定存在 $sum[i]&#x3D;target, i \in [l,r]$。所以我们可以维护区间 $\min, \max$ 并在线段树查询时作为参数传入，首先检查左子区间是否存在 $target$ 值，如果存在则进入，否则进入右子区间。这个复杂度是 $O(\log n)$ 的。</p><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\(', '\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
    
    
    <categories>
      
      <category>做题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>题解</tag>
      
      <tag>力扣</tag>
      
      <tag>线段树</tag>
      
      <tag>前缀和</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MLLMs论文学习笔记</title>
    <link href="/2026/02/09/MLLMs%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2026/02/09/MLLMs%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Crab-A-Unified-Audio-Visual-Scene-Understanding-Model-with-Explicit-Cooperation"><a href="#Crab-A-Unified-Audio-Visual-Scene-Understanding-Model-with-Explicit-Cooperation" class="headerlink" title="Crab: A Unified Audio-Visual Scene Understanding Model with Explicit Cooperation"></a>Crab: A Unified Audio-Visual Scene Understanding Model with Explicit Cooperation</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>现在音频-视觉的多模态大模型能完成很多任务，比如：</p><ul><li><strong>时间定位：</strong> 在视频中找出某事件发生的时间段;</li><li><strong>空间定位：</strong> 找出声音来源、动作主体的位置；</li><li><strong>时空推理：</strong> 推理事件的因果关系、动作意图；</li><li><strong>像素级理解：</strong> 像素级的图像分割、目标检测。</li></ul><p>显然这些任务之间是有 <strong>内在联系</strong> 的，比如时间定位、空间定位可能需要时空推理提供理解上的帮助，像素级分割需要先大致进行时间空间定位等。而现在简单的多任务联合训练不能很好地利用这种内在联系，有待改进。</p><p>让我们首先来看看什么是“简单的多任务联合训练”。最原始的阶段，多任务是通过使用不同的输出头来实现的，同一个 backbone，给每个任务一个输出头，如下图所示：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Video/Text/Audio Encoder<br><span class="hljs-code">          ↓</span><br>Multimodal Fusion<br><span class="hljs-code">          ↓</span><br>Shared Representation<br><span class="hljs-section">          ↓</span><br><span class="hljs-section">-------------------------------------</span><br>|   Task Head 1 (时间定位)           |<br>|   Task Head 2 (空间定位)           |<br>|   Task Head 3 (分割)               |<br><span class="hljs-section">|   Task Head 4 (推理)               |</span><br><span class="hljs-section">-------------------------------------</span><br></code></pre></td></tr></table></figure><p>这么做的问题非常明显，如果不冻结 backbone，那么 loss 会直接打到 backbone 上去，随着 backbone 的增大（比如 LLM）慢慢调不动了；如果冻结 backbone，那实际上只在训练一个几层的小输出头，效果很差。</p><p>这部分基本上是前 LoRA 时代的历史，在这个时代多任务联合训练是怎么进行的呢？如果不冻结 backbone，那可能还有点意义，至少不同任务都能反馈到 backbone 模型上（只要能训得动就行）；如果冻结了 backbone，共享表示就全部被冻结了，数据之间没有交互，任务没法协同。</p><p>此后，LoRA 被发明出来，通过在 LLM 内部开辟旁路的方式，用低秩矩阵来“改一点点大模型”，这让大模型微调成为可能，但是还是没有很好地解决多任务联合训练的问题。有的方法只用一组 LoRA，所有任务都是调这同一组 LoRA，不同的任务会将模型扯向不同的方向，loss scale 等问题也很成问题，最终导致训练甲任务后乙任务表现下降——这就像是一个脑力有限的人同时学八门课，把自己弄糊涂了。</p><p>而另一个方案是给每个任务一组单独的 LoRA，互不通用，这当然解决了不同任务对齐的问题，但是各个任务之间也无法互相借鉴，很大程度上丧失了联合训练的意义——八个人每人学一门课，互不交流，“数学”就没法为“物理”提供帮助了。</p><h3 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h3><p>本文有两个主要贡献：设计 AV-UIE 数据集，以及新型的多头 LoRA 机制。首先看 AV-UIE 数据集：</p><img src="/2026/02/09/MLLMs%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/av-uie.png" class="" title="AV-UIE数据集"><p>之前的数据集，不管是时间定位、空间定位还是时空推理等，其回答都是简单的。如询问“第一个响起的乐器的左侧的乐器是什么？”，其回答可能只有“大提琴”三个字；如果是时间定位，可能只有简单的“3-6 秒”几个字。作者基于已有的此类数据集进行扩展，利用 LLM 进行扩写和人工修改，在保留原来回答的基础上增加了显式的其他任务的信息，比如：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">画面中三个男人在圣诞树前演奏乐器。<br>左侧的男人在拉大提琴，中间的男人在拉小提琴，右侧的男人在弹钢琴。（空间定位）<br>第<span class="hljs-number"> 2 </span>秒开始，钢琴开始响；从第<span class="hljs-number"> 4 </span>秒开始，三个乐器一起演奏。（时间定位）<br>钢琴的左侧是大提琴，<br>所以答案是大提琴.（时空推理）<br></code></pre></td></tr></table></figure><p>通过改造数据集，在输入阶段就提供了显式的多任务联合的监督信号。</p><p>接下来看 LoRA 的设计。和一般的多模态大模型一样，Crab 模型分为前端和大模型两部分，前端采用了 Clip 作为视觉编码器，采用 BEATs 作为音频编码器，用 Q-Former 查询视觉和音频信息（控制长度），并用两层 MLP 对齐大模型 hidden layer；冻结编码器，训练 Q-Former 和 MLP：基本都是常规做法。</p><img src="/2026/02/09/MLLMs%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/model.png" class=""><p>大模型内部的 LoRA 设计是主要创新点。作者用同一套 LoRA（不是多套 LoRA 分别处理不同任务），但是将 LoRA 的低秩矩阵拆分实现为共用的 A 和多个不同的 B，即共享一部分，独立一部分；同时作者引入 Router R，输出每个 LoRA 头的权重与 LoRA 输出加权融合。</p><img src="/2026/02/09/MLLMs%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/lora.png" class=""><p>在训练部分，作者仍然是随机抽取不同任务的 batch 进行训练（但是使用 AV-UIE 数据集），loss 也仍然是不同任务的加权和。</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多模态大模型</tag>
      
      <tag>LoRA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1878D Reverse Madness</title>
    <link href="/2025/12/08/CF1878D-Reverse-Madness/"/>
    <url>/2025/12/08/CF1878D-Reverse-Madness/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1878/problem/D" title="观察式子发现结论。">传送门。</a>有这样一个结论，由 $x$ 得到的反转区间 $[a,b]$ 的对称轴就是 $x$ 所在的题给区间 $[l,r]$ 的对称轴，且 $[a,b]\subset [l,r]$。</p><p>这个结论有什么用？如果没有这个结论，我们离线 $q$ 次询问得到的是一系列散乱的反转区间。因为反转区间可能有覆盖、重叠，要得到答案只能暴力地 $O(qn)$ 去反转 $s$，没法整合在一起来降低复杂度。但是一旦有了这个结论，我们就知道：反转区间要么不重叠，要么关于同一个轴对称，我们可以把同轴对称（$x$ 属于同一个区间）的反转区间整合在一起。</p><p>如何整合？朴素的想法是把每个反转区间在原序列上标记 +1。如果一个位置被奇数个反转区间覆盖，则与其对称位置交换；否则不交换。因为只有一次查询，所以可用差分+前缀和优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k; string s;<br>    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(k + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">r</span><span class="hljs-params">(k + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-comment">// c记录x所属区间，p为差分数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) cin &gt;&gt; l[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>        cin &gt;&gt; r[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = l[i]; j &lt;= r[i]; j++) c[j] = i;<br>    &#125;<br>    <span class="hljs-type">int</span> q; cin &gt;&gt; q;<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> x; cin &gt;&gt; x;<br>        <span class="hljs-type">int</span> a = <span class="hljs-built_in">min</span>(x, r[c[x]] + l[c[x]] - x);<br>        <span class="hljs-type">int</span> b = <span class="hljs-built_in">max</span>(x, r[c[x]] + l[c[x]] - x);<br>        p[a]++, p[b + <span class="hljs-number">1</span>]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) p[i] += p[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = l[i]; j &lt;= (l[i] + r[i]) / <span class="hljs-number">2</span>; j++)<br>            <span class="hljs-keyword">if</span> (p[j] &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">swap</span>(s[j - <span class="hljs-number">1</span>], s[r[i] + l[i] - j - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 如果被奇数个区间覆盖即交换</span><br>    cout &lt;&lt; s &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
    
    
    <categories>
      
      <category>做题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>题解</tag>
      
      <tag>差分</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1879D Sum of XOR Functions</title>
    <link href="/2025/12/08/CF1879D-Sum-of-XOR-Functions/"/>
    <url>/2025/12/08/CF1879D-Sum-of-XOR-Functions/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/1879/D" title="异或和按位处理的典型例题。">异或和按位处理的典型例题。</a>要求所有子区间异或和乘区间长度的总和，朴素的方法是 $O(n^2)$ 地枚举区间，显然无法通过。</p><p>因为涉及异或和，而异或运算不进位，故自然地想到<strong>把 $a_i$ 写成二进制形式，单独研究每一位的贡献</strong>，最后再合并。这是处理此类问题的一般思路。</p><h3 id="1-二进制拆分"><a href="#1-二进制拆分" class="headerlink" title="1. 二进制拆分"></a>1. 二进制拆分</h3><p>比方说，对于如下样例，我们把 $a_i$ 写成二进制形式：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>  = <span class="hljs-number">0101</span><br><span class="hljs-attribute">a</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">11</span> = <span class="hljs-number">1011</span><br><span class="hljs-attribute">a</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">7</span>  = <span class="hljs-number">0111</span><br><span class="hljs-attribute">a</span>[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>  = <span class="hljs-number">0100</span><br></code></pre></td></tr></table></figure><p>第 $0$ 位可以提出来，变成一个 01 串 <code>1110</code>，第 $1$ 位提出来，得到 <code>0110</code>……</p><h3 id="2-对每一位求贡献"><a href="#2-对每一位求贡献" class="headerlink" title="2. 对每一位求贡献"></a>2. 对每一位求贡献</h3><p>二进制拆分后，问题也就转化成了：对每个 01 串求所有含有奇数个 $1$ 的区间的区间长度和 $res$（因为只有含奇数个 $1$ 的区间，异或和才为 $1$，长度才会被计入贡献）。</p><p>下面用 dp 求 $res$：</p><p>要研究区间，往往通过前缀来转化。有哪些情况能使得区间 $[l,r]$ 有奇数个 $1$ 呢？</p><ul><li>如果区间 $[1,r]$ 有奇数个 $1$，区间 $[1,l]$ 有偶数个 $1$，则区间 $[l,r]$ 有奇数个 $1$；</li><li>如果区间 $[1,r]$ 有偶数个 $1$，区间 $[1,l]$ 有奇数个 $1$，则区间 $[l,r]$ 有奇数个 $1$。</li></ul><p>由此，我们</p><ul><li>设 $cnt_{i,0&#x2F;1}$ 表示在 $[1,i]$ 中，有多少个前缀含有偶数&#x2F;奇数个 $1$；</li><li>设 $sum_{i,0&#x2F;1}$ 表示在 $[1,i]$ 中，含有偶数&#x2F;奇数个 $1$ 的前缀总长度是多少；</li><li>设 $len_i$ 表示恰好以 $i$ 结尾的含有奇数个 $1$ 的区间的总长度，显然 $res&#x3D;\sum len_i$。</li></ul><p>于是有</p><p>$len_i &#x3D; cnt_{i-1,0}\times i-sum_{i-1,0}$，若 $[1,i]$ 有偶数个 $1$;<br>$len_i &#x3D; cnt_{i-1,1}\times i-sum_{i-1,1}$，若 $[1,i]$ 有奇数个 $1$。</p><p>这实质上是把所有前缀和作差求区间和的操作放在一起做。</p><h3 id="3-合并每一位统计答案"><a href="#3-合并每一位统计答案" class="headerlink" title="3. 合并每一位统计答案"></a>3. 合并每一位统计答案</h3><p>最终的答案 $ans&#x3D;\sum\limits_{i&#x3D;0}^{30} res_i\times 2^i$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, ans = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt;= <span class="hljs-number">30</span>; t++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            b[i] = (a[i] &gt;&gt; t) &amp; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;   <span class="hljs-comment">// the number of 1s</span><br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// the number of the intervals</span><br>        <span class="hljs-type">int</span> sum[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// the sum of the intervals&#x27; lengthes</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            x = (x + b[i]) % <span class="hljs-number">2</span>;<br>            res = (res + (LL)cnt[<span class="hljs-number">1</span> - x] * i % mod - sum[<span class="hljs-number">1</span> - x] + mod) % mod;<br>            cnt[x]++, sum[x] = (sum[x] + i) % mod;<br>        &#125;<br>        ans = (ans + (LL)res * ((<span class="hljs-number">1</span> &lt;&lt; t) % mod) % mod) % mod;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
    
    
    <categories>
      
      <category>做题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>题解</tag>
      
      <tag>Codeforces</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cJSON源码学习笔记</title>
    <link href="/2025/12/08/cJSON%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/12/08/cJSON%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> cJSON__h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON__h</span><br></code></pre></td></tr></table></figure><p>避免头文件重复定义。首先检查是否已经包含了 <code>cJSON__h</code> 宏，如果没有包含则包含之并执行下面的代码；如果已经包含则跳过这段代码，避免了同一份文件的重复执行，导致同一个文件内类和结构体等被多次定义等问题（至少造成了编译时间增加）。对应的 <code>#endif</code> 在文件的末尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>__cplusplus</code> 是 g++ 编译器定义的宏，这段话就是说，如果使用 C++ 编译器编译这个文件，就执行 <code>extern &quot;C&quot; {}</code> 代码，把全文包含进去。</p><p><strong>extern 关键字：</strong> 全局变量默认具有外部链接属性（在外部需要使用 extern 关键字声明），如果用 static 修饰就变成了内部链接属性（不能在外部调用）。函数默认具有外部链接属性，可以在外部直接调用，static 修饰就变成了内部链接属性。</p><blockquote><p>为什么要在头文件中 extern？<br>头文件是声明变量而不是定义变量的地方，我们通过 extern 把变量的作用域从定义变量的文件扩展到了头文件，进而扩展到了包含头文件的源文件，使得变量在源文件可用。</p></blockquote><p><strong>extern “C”</strong>： 首先起到了 extern 的作用。其次，当 C++ 编译器编译代码时，会进行 <strong>函数名修饰</strong>。因为 C++ 支持函数重载，编译器会把 <code>void print(int x)</code> 和 <code>void print(double x)</code> 在内部改写成不同的名字，比如 <code>_Z3printi</code> 和 <code>_Z3printd</code>。但是 C 不支持函数重载，所以 <code>void print(int x)</code> 的名字就是 <code>_print</code>。这导致用 C 编译器编译的文件和 C++ 编译器编译的文件链接时，可能出现“找不到函数”的问题。用 extern “C” 修饰的函数会强制按照 C 语言的方式来编译，以避免链接的时候找不到对应的函数，出现错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(__WINDOWS__) &amp;&amp; (defined(WIN32) || defined(WIN64) || defined(_MSC_VER) || defined(_WIN32))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __WINDOWS__</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>把不同的 Windows 版本的宏定义统一成 <code>__WINDOWS__</code></p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __WINDOWS__</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_CDECL __cdecl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_STDCALL __stdcall</span><br></code></pre></td></tr></table></figure><p>定义了两种 C 语言中的调用约定，<code>__cdecl</code> 是默认的调用约定，规定由调用者清理栈帧；<code>__stdcall</code> 是 Windows API 的调用约定，规定由被调用者清理栈帧。</p><blockquote><p>调用者清理：主要是 cdecl，即 C 语言的默认调用约定。规定参数从右往左入栈，调用者清理栈帧，使得可变长参数得以实现，函数名前缀_（函数名修饰）；<br>被调用者清理：Pascal 规约是 Pascal 语言的默认调用约定，参数从左往右入栈，被调用者清理栈帧；stdcall 是微软的调用约定，参数从右往左入栈，被调用者清理栈帧，编译的函数名前缀_，后缀@及栈空间长度。这种约定不允许可变参数，但是更有效率，解堆栈的代码不需要每次调用时生成一遍。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* export symbols by default, this is necessary for copy pasting the C and header file */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(CJSON_HIDE_SYMBOLS) &amp;&amp; !defined(CJSON_IMPORT_SYMBOLS) &amp;&amp; !defined(CJSON_EXPORT_SYMBOLS)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_EXPORT_SYMBOLS</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>如果没有定义 <code>CJSON_HIDE_SYMBOLS</code> 和 <code>CJSON_IMPORT_SYMBOLS</code>，就定义 <code>CJSON_EXPORT_SYMBOLS</code>（默认）。</p><ul><li><code>CJSON_HIDE_SYMBOLS</code>：不导出任何符号，一般用于构建静态库；</li><li><code>CJSON_EXPORT_SYMBOLS</code>：把符号导出到 dll 中，供用户使用；</li><li><code>CJSON_IMPORT_SYMBOLS</code>：客户端程序声明从 dll 中导入符号。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CJSON_HIDE_SYMBOLS)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_PUBLIC(type)   type CJSON_STDCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CJSON_EXPORT_SYMBOLS)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_PUBLIC(type)   __declspec(dllexport) type CJSON_STDCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CJSON_IMPORT_SYMBOLS)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_PUBLIC(type)   __declspec(dllimport) type CJSON_STDCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* !__WINDOWS__ */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_CDECL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_STDCALL</span><br></code></pre></td></tr></table></figure><p>调用 Windows API <code>__declspec(dllexport)</code> 等进行具体实现。最后定义空宏，保证在其它平台上宏仍然存在但无实际意义。</p><p>注意到 EXPORT 和 IMPORT 分别是属于开发者和客户端的行为，但都定义在同一个头文件中，这体现了头文件的共享性。开发者在构建静态库或者动态链接库的时候，可以通过编译指令定义 <code>CJOSN_EXPORT_SYMBOLS</code>，这样代码中所有签名为 <code>CJSON_PUBLIC(int) func(...)</code> 的函数就被展开为 <code>__declspec(dllexport) int func(...)</code>，从而编译器知道要将它们导出到 dll 中。而客户端在编译的时候可以指定 <code>CJSON_IMPORT_SYMBOLS</code>，并包含头文件，则头文件中的 <code>CJSON_PUBLIC(int)</code> 就会替换成 <code>__declspec(dllimport) int</code>，编译器自动去 dll 中寻找对应的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> (defined(__GNUC__) || defined(__SUNPRO_CC) || defined (__SUNPRO_C)) &amp;&amp; defined(CJSON_API_VISIBILITY)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_PUBLIC(type)   __attribute__((visibility(<span class="hljs-string">&quot;default&quot;</span>))) type</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_PUBLIC(type) type</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>在支持 <code>__attribute__((visibility(&quot;default&quot;)))</code> 的编译器中，通过显式声明控制符号对外可见；如果当前环境不支持，则不做任何修饰。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_VERSION_MAJOR 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_VERSION_MINOR 7</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_VERSION_PATCH 18</span><br></code></pre></td></tr></table></figure><p>定义版本号，用户可以通过 <code>#if (CJSON_VERSION_MAJOR &gt;= 1 &amp;&amp; CJSON_VERSION_MINOR &gt;= 7) #else #endif</code> 这样的条件编译来启用新版本特性和兼容旧版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* cJSON Types: */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_Invalid (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_False  (1 &lt;&lt; 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_True   (1 &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_NULL   (1 &lt;&lt; 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_Number (1 &lt;&lt; 3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_String (1 &lt;&lt; 4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_Array  (1 &lt;&lt; 5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_Object (1 &lt;&lt; 6)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_Raw    (1 &lt;&lt; 7) <span class="hljs-comment">/* raw json */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_IsReference 256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_StringIsConst 512</span><br></code></pre></td></tr></table></figure><p>定义基本类型，使用位运算的好处是可以高效地进行判断，比如 <code>if (item-&gt;type &amp; cJSON_String)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cJSON</span><br>&#123;<br>    <span class="hljs-comment">/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cJSON</span> *next;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cJSON</span> *prev;<br>    <span class="hljs-comment">/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cJSON</span> *child;<br><br>    <span class="hljs-comment">/* The type of the item, as above. */</span><br>    <span class="hljs-type">int</span> type;<br><br>    <span class="hljs-comment">/* The item&#x27;s string, if type==cJSON_String  and type == cJSON_Raw */</span><br>    <span class="hljs-type">char</span> *valuestring;<br>    <span class="hljs-comment">/* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */</span><br>    <span class="hljs-type">int</span> valueint;<br>    <span class="hljs-comment">/* The item&#x27;s number, if type==cJSON_Number */</span><br>    <span class="hljs-type">double</span> valuedouble;<br><br>    <span class="hljs-comment">/* The item&#x27;s name string, if this item is the child of, or is in the list of subitems of an object. */</span><br>    <span class="hljs-type">char</span> *string;<br>&#125; cJSON;<br></code></pre></td></tr></table></figure><ul><li>next 和 prev 把同一层级的节点构建成双向链表；</li><li>如果这个位置的节点是一个对象或者数组，child 指向对象或数组的第一个节点（元素）；</li><li>type 是上面的 6 种基本类型之一；</li><li>valuestring, valueint, valuedouble 存储当前节点的数据；当前节点数据是什么类型的，就存储在哪个变量中，剩下两个为空；如果都不是，则都为空；</li><li>string 存储键名。</li></ul><p>举例说明，如果有以下的 JSON，则：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;key1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;key2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nestedKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nestedValue&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;key3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>根节点的 child 指向 key1；</li><li>key1, key2, key3 组成双向链表；</li><li>key1 节点的 type 为 CJSON_String， string 为 “key1”，valuestring 为 “value1”；</li><li>key2 节点的 child 指向 nestedKey，key3 节点的 child 指向数组第一个元素 1;</li><li>因为 cJSON 的思想是把所有数据类型都统一成 cJSON 节点，所以数组中的元素也是一个个 cJSON 节点。</li></ul><p>cJSON 的链表结构便于增删节点，无需重新分配内存。</p><h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cJSON_Hooks</span></span><br><span class="hljs-class">&#123;</span><br>      <span class="hljs-comment">/* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */</span><br>      <span class="hljs-type">void</span> *(CJSON_CDECL *malloc_fn)(<span class="hljs-type">size_t</span> sz);<br>      <span class="hljs-type">void</span> (CJSON_CDECL *free_fn)(<span class="hljs-type">void</span> *ptr);<br>&#125; cJSON_Hooks;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> cJSON_bool;<br></code></pre></td></tr></table></figure><p>cJSON_Hooks 结构体提供了一个接口，允许实现自定义的内存管理函数。<code>*malloc_fn</code> 传入分配的内存大小，返回分配的内存地址；<code>*free_fn</code> 传入要释放的内存指针。两个都强制声明为 <code>CJSON_CDECL</code> 的，保证在 Windows 平台下 malloc 和 free 由调用者清理栈帧（与标准库的实现统一）。</p><p>cJSON_bool 是自定义的布尔类型。在早期的 C 语言中没有布尔类型，为了统一行为，使用 int 自定义布尔类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Limits how deeply nested arrays/objects can be before cJSON rejects to parse them.</span><br><span class="hljs-comment"> * This is to prevent stack overflows. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CJSON_NESTING_LIMIT</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_NESTING_LIMIT 1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>cJSON 通过递归的方式来处理嵌套，而每次递归都需要压栈。如果嵌套层数过多，可能引发栈溢出，所以有必要定义一个嵌套上限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Limits the length of circular references can be before cJSON rejects to parse them.</span><br><span class="hljs-comment"> * This is to prevent stack overflows. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CJSON_CIRCULAR_LIMIT</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CJSON_CIRCULAR_LIMIT 10000</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>限制循环引用同样是为了避免爆栈。原生 JSON 中不支持引用，如果引入了 ref 则可能出现循环引用，如：<code>{&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;ref&quot;: &quot;$a&quot;}}}}</code> 而其他依赖于引用计数的语言可能因为循环引用而无法垃圾回收。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树时间分治</title>
    <link href="/2025/12/08/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%97%B6%E9%97%B4%E5%88%86%E6%B2%BB/"/>
    <url>/2025/12/08/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%97%B6%E9%97%B4%E5%88%86%E6%B2%BB/</url>
    
    <content type="html"><![CDATA[<p>线段树时间分治解决的问题是一类可离线的，要求支持先修改后撤销，查询某一时间点前修改的总贡献的问题。大致的思路是，在时间轴上建一棵线段树，把 $l$ 时刻修改，$r+1$ 时刻撤销的操作，“区间加”到 $[l,r]$ 区间上。然后遍历线段树所有节点（时间区间），$O(n\log n)$ 地统计出每个时间的答案。</p><p>以洛谷模板题 <a href="https://www.luogu.com.cn/problem/P5787" title="P5787 二分图 &#x2F;【模板】线段树分治">P5787 二分图 &#x2F;【模板】线段树分治</a> 为例：有一张 $n$ 个节点 $m$ 条边的无向图。但 $m$ 条边在时间 $[1,k]$ 内不是一直存在的——第 $i$ 条边 $(u_i,v_i)$ 在时间 $l_i$ 开始出现，到 $r_i$ 消失。你需要对每个时间点 $i\in[1,k]$ 判断此时这个图是否为二分图。</p><p>“先出现后消失”可以转换成 $l_i$ 时刻加边，$r_i$ 时刻撤销。而对于每个时间是否是二分图，可以用扩展域并查集进行判定。它支持动态维护，且可以撤销，符合线段树分治的条件（也因此不能使用染色法）。</p><p>我们把这个操作“加”到线段树上去。具体写法是在线段树的每个节点上开一个 vector，然后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;<br>        t[p].v.<span class="hljs-built_in">emplace_back</span>(x); <span class="hljs-comment">// x是修改操作的编号</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid) <span class="hljs-built_in">insert</span>(ls, l, r, x);<br>    <span class="hljs-keyword">if</span> (r &gt; mid) <span class="hljs-built_in">insert</span>(rs, l, r, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>把所有的修改放上线段树之后，每个节点的 vector 中存储的就是所有<strong>在整个这个时间段内存在的边</strong>。此时可以从上到下遍历整个线段树，并维护一个扩展域并查集。当走到一个时间段，把这个节点上的边加入并查集，发现出现了矛盾，则这个时间段内一定不是二分图，不需要再向下递归了，直接把这个区间全部标记为 <code>No</code>；否则继续向下递归。回溯的时候，需要撤销当前时间段内加上的边，可以使用可撤销化并查集（用栈记录合并，复原现场）。因为使用了可撤销化，不能路径压缩，必须按秩合并保证复杂度。</p><p>下面是遍历部分的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-comment">// 路径压缩会丢失父亲信息，导致无法撤销</span><br>    <span class="hljs-keyword">while</span> (x != fa[x]) x = fa[x];<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br>stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; memo;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (d[x] &gt; d[y]) <span class="hljs-built_in">swap</span>(x, y); <span class="hljs-comment">// 按秩合并：树高小的往大的上面合并（连到根节点）</span><br>    memo.<span class="hljs-built_in">emplace</span>(x, d[x] == d[y]); <span class="hljs-comment">// 记录合并</span><br>    fa[x] = y;<br>    d[y] += d[x] == d[y]; <span class="hljs-comment">// 如果树高相等，总树高+1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> siz = memo.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : t[p].v) &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(u[i]), y = <span class="hljs-built_in">find</span>(v[i]);<br>        <span class="hljs-keyword">if</span> (x == y) &#123; <span class="hljs-comment">// 如果出现矛盾（两个节点属于同一部）</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = l; j &lt;= r; j++) cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;<br>            <span class="hljs-keyword">goto</span> DRAW_BACK;<br>        &#125;<br>        <span class="hljs-built_in">merge</span>(x, <span class="hljs-built_in">find</span>(v[i] + n));<br>        <span class="hljs-built_in">merge</span>(y, <span class="hljs-built_in">find</span>(u[i] + n));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">dfs</span>(ls, l, mid);<br>        <span class="hljs-built_in">dfs</span>(rs, mid + <span class="hljs-number">1</span>, r);<br>    &#125;<br>DRAW_BACK:<br>    <span class="hljs-keyword">while</span> (memo.<span class="hljs-built_in">size</span>() &gt; siz) &#123; <span class="hljs-comment">// 把这一部分新加的边全部撤销掉</span><br>        <span class="hljs-keyword">auto</span> [x, v] = memo.<span class="hljs-built_in">top</span>();<br>        memo.<span class="hljs-built_in">pop</span>();<br>        d[<span class="hljs-built_in">find</span>(x)] -= v, fa[x] = x;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// main()</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n * <span class="hljs-number">2</span>; i++) fa[i] = i;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, k);<br></code></pre></td></tr></table></figure><p>今年辽宁省赛的 K 题<a href="https://qoj.ac/contest/1831/problem/9588" title="可重集合">可重集合</a>也是线段树分治，当时被卡住不会处理错失前三，现在可以补了。题目要求维护一个可重集合，支持元素的增加和删除，在每一次操作后输出集合中元素通过加法组合能生成多少个不同的正整数。</p><p>注意到可以背包 dp，设 $dp_i$ 表示数字 $i$ 能否被表示出来，显然 $dp_i\in {0,1}$ 且有转移方程 $dp[i]∣&#x3D;dp[i−a[j]]$，复杂度 $O(mn)$。这是 bitset 优化背包的模板，直接转化为 $dp∣&#x3D;dp≪i$，复杂度 $O(\frac{nm}{w})$。</p><p>因为有删除操作，所以上线段树分治。根据插入删除的时间确定每个元素在时间轴上存在的区间，递归处理即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>; <span class="hljs-comment">// x[i]的上界</span><br><span class="hljs-type">int</span> n, x[N], ans[N];<br>unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; s;<br>bitset&lt;M&gt; dp;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">segtree</span> &#123;<br>    <span class="hljs-type">int</span> l, r;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>&#125; t[N &lt;&lt; <span class="hljs-number">2</span>];<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid ((t[p].l + t[p].r) &gt;&gt; 1)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    t[p].l = l, t[p].r = r;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">build</span>(ls, l, mid), <span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;<br>        t[p].v.<span class="hljs-built_in">emplace_back</span>(x);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid) <span class="hljs-built_in">insert</span>(ls, l, r, x);<br>    <span class="hljs-keyword">if</span> (r &gt; mid) <span class="hljs-built_in">insert</span>(rs, l, r, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    bitset&lt;M&gt; tmp = dp; <span class="hljs-comment">// 记录状态</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : t[p].v) dp |= dp &lt;&lt; i; <span class="hljs-comment">// bitset优化背包</span><br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        ans[l] = dp.<span class="hljs-built_in">count</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 有多少个1就是有多少个数能表示（-1减去0）</span><br>        dp = tmp;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(ls, l, mid);<br>    <span class="hljs-built_in">dfs</span>(rs, mid + <span class="hljs-number">1</span>, r);<br>    dp = tmp; <span class="hljs-comment">// 回溯</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>)-&gt;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, op; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; op &gt;&gt; x[i];<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            s[x[i]].<span class="hljs-built_in">emplace_back</span>(i); <span class="hljs-comment">// 记录可重集内所有x[i]的下标（起点）</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>, s[x[i]].<span class="hljs-built_in">back</span>(), i - <span class="hljs-number">1</span>, x[i]); <span class="hljs-comment">// 遇到删除操作，把到这为止的一段加进去</span><br>            s[x[i]].<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [i, v] : s) &#123;<br>        <span class="hljs-keyword">if</span> (v.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : v) <span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>, j, n, i); <span class="hljs-comment">// 没有删除的，直接覆盖到最后</span><br>    &#125;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化，0一定能被表示</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
    
    
    <categories>
      
      <category>做题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pbds学习笔记</title>
    <link href="/2025/12/08/pbds%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/12/08/pbds%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>pbds 是 GNU 扩展库的一部分，在 g++ 环境下可以直接使用，clang 下不能使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/extc++.h&gt;</span> <span class="hljs-comment">// pbds 万能头</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_cxx;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_pbds;<br></code></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext/pb_ds/priority_queue.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_pbds;<br><br><span class="hljs-keyword">using</span> heap = __gnu_pbds::priority_queue&lt;<span class="hljs-type">int</span>&gt;; <span class="hljs-comment">// 默认大根堆</span><br>heap q;<br><span class="hljs-keyword">using</span> small_heap = __gnu_pbds::priority_queue&lt;<span class="hljs-type">int</span>, less&lt;<span class="hljs-type">int</span>&gt;&gt;; <span class="hljs-comment">// 小根堆</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myCmp</span> &#123; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(node x, node y)</span> </span>&#123; <span class="hljs-keyword">return</span> x.b &lt; y.b; &#125; &#125;; <span class="hljs-comment">// 也可以在自定义类型里重载运算符</span><br><span class="hljs-keyword">using</span> my_heap = __gnu_pbds::priority_queue&lt;node, myCmp&gt;;<br><br>q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>(); q.<span class="hljs-built_in">size</span>(); q.<span class="hljs-built_in">empty</span>(); q.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 和 STL 完全一样</span><br>id = q.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 效果和 STL 一样，会多返回一个指向插入的元素的迭代器（可以不接收）复杂度 O(1)</span><br>q.<span class="hljs-built_in">modify</span>(id, <span class="hljs-number">5</span>); <span class="hljs-comment">// 直接修改迭代器位置的元素，复杂度均摊 O(log n)</span><br>q.<span class="hljs-built_in">erase</span>(id); <span class="hljs-comment">// 直接删除迭代器位置的元素，均摊 O(log n)</span><br>q.<span class="hljs-built_in">join</span>(p); <span class="hljs-comment">// 把堆p合并到堆q，p清空，复杂度 O(1)</span><br></code></pre></td></tr></table></figure><p>modify 的一个应用是在 Dijkstra 中可以直接修改堆内元素，不需要重复插入+ $vis$ 数组记录。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_pbds;<br>gp_hash_table&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; gp_table;<br>cc_hash_table&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cc_table;<br><br><span class="hljs-comment">// 用时间设置哈希值防卡，codeforces 常用</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> RANDOM = chrono::high_resolution_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>().<span class="hljs-built_in">count</span>();<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">chash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x ^ RANDOM; &#125;<br>    <span class="hljs-comment">// 如果要用 string 之类的类型作为 key，可以调用 std::hash</span><br>    hash&lt;string&gt; hasher;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string s)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasher</span>(s) ^ RANDOM; &#125;<br>    <span class="hljs-comment">// std::pair 没有默认的哈希，需要自定义</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; x)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x.first* <span class="hljs-number">31</span> + x.second; &#125;<br>&#125;;<br>cc_hash_table&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, chash&gt; table1;<br>cc_hash_table&lt;string, <span class="hljs-type">int</span>, chash&gt; table2;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XCPC代码模板</title>
    <link href="/2025/12/08/XCPC%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
    <url>/2025/12/08/XCPC%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//扩展域并查集注意开n*3+1</span><br><span class="hljs-built_in">iota</span>(fa.<span class="hljs-built_in">begin</span>(), fa.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 带权并查集则同时更新d[x],siz[x]</span><br>function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; find = [&amp;](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]); &#125;;<br><span class="hljs-keyword">auto</span> unite = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123; fa[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y); &#125;;<br></code></pre></td></tr></table></figure><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; sum[p] = sum[ls[p]] + sum[rs[p]]; &#125;<br><span class="hljs-comment">//动态开点权值线段树</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) p = ++tot;<br>    <span class="hljs-keyword">if</span> (l == r) &#123; sum[p]++; <span class="hljs-keyword">return</span> p; &#125;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    x &lt;= mid ? ls[p] = <span class="hljs-built_in">add</span>(ls[p], l, mid, x) : rs[p] = <span class="hljs-built_in">add</span>(rs[p], mid + <span class="hljs-number">1</span>, r, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">refresh</span>(p), p;<br>&#125;<br><span class="hljs-comment">//线段树合并</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> q;<br>    <span class="hljs-keyword">if</span> (!q) <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-keyword">if</span> (l == r) &#123; sum[p] += sum[q]; <span class="hljs-keyword">return</span> p; &#125;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid) ls[p] = <span class="hljs-built_in">merge</span>(ls[p], ls[q], l, mid);<br>    <span class="hljs-keyword">if</span> (r &gt; mid) rs[p] = <span class="hljs-built_in">merge</span>(rs[p], rs[q], mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">refresh</span>(p), p;<br>&#125;<br><span class="hljs-comment">//线段树上二分</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (sum[ls[p]] &gt;= k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(ls[p], l, mid, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(rs[p], mid + <span class="hljs-number">1</span>, r, k - sum[ls[p]]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="吉老师线段树"><a href="#吉老师线段树" class="headerlink" title="吉老师线段树"></a>吉老师线段树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">seg</span> &#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> vmax, vmaxh, vsec, mxcnt, sum;<br>    <span class="hljs-type">int</span> tmax, telse, tmaxh, telseh;<br>&#125; t[MAXN &lt;&lt; <span class="hljs-number">2</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid ((t[p].l + t[p].r) &gt;&gt; 1)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    t[p].vmax = <span class="hljs-built_in">max</span>(t[ls].vmax, t[rs].vmax);<br>    t[p].vmaxh = <span class="hljs-built_in">max</span>(t[ls].vmaxh, t[rs].vmaxh);<br>    t[p].sum = t[ls].sum + t[rs].sum;<br>    <span class="hljs-keyword">if</span> (t[ls].vmax == t[rs].vmax) &#123;<br>        t[p].vsec = <span class="hljs-built_in">max</span>(t[ls].vsec, t[rs].vsec);<br>        t[p].mxcnt = t[ls].mxcnt + t[rs].mxcnt;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t[ls].vmax &gt; t[rs].vmax) &#123;<br>        t[p].vsec = <span class="hljs-built_in">max</span>(t[ls].vsec, t[rs].vmax);<br>        t[p].mxcnt = t[ls].mxcnt;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        t[p].vsec = <span class="hljs-built_in">max</span>(t[ls].vmax, t[rs].vsec);<br>        t[p].mxcnt = t[rs].mxcnt;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    t[p].l = l, t[p].r = r;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        cin &gt;&gt; t[p].vmaxh;<br>        t[p].sum = t[p].vmax = t[p].vmaxh;<br>        t[p].vsec = -INF;<br>        t[p].mxcnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">build</span>(ls, l, mid), <span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">refresh</span>(p);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addtag</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> tmax, <span class="hljs-type">int</span> tmaxh, <span class="hljs-type">int</span> telse, <span class="hljs-type">int</span> telseh)</span> </span>&#123;<br>    t[p].sum += t[p].mxcnt * tmax + (t[p].r - t[p].l + <span class="hljs-number">1</span> - t[p].mxcnt) * telse;<br>    t[p].vmaxh = <span class="hljs-built_in">max</span>(t[p].vmaxh, t[p].vmax + tmaxh);<br>    t[p].tmaxh = <span class="hljs-built_in">max</span>(t[p].tmaxh, t[p].tmax + tmaxh);<br>    t[p].telseh = <span class="hljs-built_in">max</span>(t[p].telseh, t[p].telse + telseh);<br>    t[p].vmax += tmax;<br>    t[p].tmax += tmax;<br>    t[p].telse += telse;<br>    <span class="hljs-keyword">if</span> (t[p].vsec != -INF) t[p].vsec += telse;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">max</span>(t[ls].vmax, t[rs].vmax);<br>    <span class="hljs-keyword">if</span> (t[ls].vmax == tmp) <span class="hljs-built_in">addtag</span>(ls, t[p].tmax, t[p].tmaxh, t[p].telse, t[p].telseh);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">addtag</span>(ls, t[p].telse, t[p].telseh, t[p].telse, t[p].telseh);<br>    <span class="hljs-keyword">if</span> (t[rs].vmax == tmp) <span class="hljs-built_in">addtag</span>(rs, t[p].tmax, t[p].tmaxh, t[p].telse, t[p].telseh);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">add_tag</span>(rs, t[p].telse, t[p].telseh, t[p].telse, t[p].telseh);<br>    t[p].tmax = t[p].tmaxh = t[p].telse = t[p].telseh = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cadd</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;<br>        <span class="hljs-built_in">add_tag</span>(p, val, val, val, val);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-keyword">if</span> (l &lt;= mid) <span class="hljs-built_in">cadd</span>(ls, l, r, val);<br>    <span class="hljs-keyword">if</span> (r &gt; mid) <span class="hljs-built_in">cadd</span>(rs, l, r, val);<br>    <span class="hljs-built_in">refresh</span>(p);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cmin</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (val &gt;= t[p].vmax) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r &amp;&amp; val &gt; t[p].vsec) &#123;<br>        <span class="hljs-built_in">add_tag</span>(p, val - t[p].vmax, val - t[p].vmax, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-keyword">if</span> (l &lt;= mid) <span class="hljs-built_in">cmin</span>(ls, l, r, val);<br>    <span class="hljs-keyword">if</span> (r &gt; mid) <span class="hljs-built_in">cmin</span>(rs, l, r, val);<br>    <span class="hljs-built_in">refresh</span>(p);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qsum</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) <span class="hljs-keyword">return</span> t[p].sum;<br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid) ans += <span class="hljs-built_in">qsum</span>(ls, l, r);<br>    <span class="hljs-keyword">if</span> (r &gt; mid) ans += <span class="hljs-built_in">qsum</span>(rs, l, r);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmax</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) <span class="hljs-keyword">return</span> t[p].vmax;<br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-type">int</span> ans = -INF;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid) ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">qmax</span>(ls, l, r));<br>    <span class="hljs-keyword">if</span> (r &gt; mid) ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">qmax</span>(rs, l, r));<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmaxh</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) <span class="hljs-keyword">return</span> t[p].vmaxh;<br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-type">int</span> ans = -INF;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid) ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">qmaxh</span>(ls, l, r));<br>    <span class="hljs-keyword">if</span> (r &gt; mid) ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">qmaxh</span>(rs, l, r));<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="李超树"><a href="#李超树" class="headerlink" title="李超树"></a>李超树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">seg</span> &#123;<br>    <span class="hljs-type">double</span> k, b;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> x0, <span class="hljs-type">int</span> y0, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x0 == x1) k = <span class="hljs-number">0</span>, b = <span class="hljs-built_in">max</span>(y0, y1);<br>        <span class="hljs-keyword">else</span> k = <span class="hljs-number">1.0</span> * (y1 - y0) / (x1 - x0), b = y0 - k * x0;<br>    &#125;<br>&#125; a[MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">double</span> y;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node &amp;a) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(y - a.y) &lt; eps) <span class="hljs-keyword">return</span> id &gt; a.id;<br>        <span class="hljs-keyword">return</span> y &lt; a.y;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//第id条直线在x处取值</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> a[id].k * x + a[id].b; &#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">segtree</span> &#123;<br>    <span class="hljs-type">int</span> l, r, id;<br>&#125; t[MAXN &lt;&lt; <span class="hljs-number">2</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid ((t[p].l + t[p].r) &gt;&gt; 1)</span><br><span class="hljs-comment">//建树build(1,1,n)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    t[p].l = l, t[p].r = r;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">build</span>(ls, l, mid), <span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (!t[p].id) &#123; t[p].id = id; <span class="hljs-keyword">return</span>; &#125;<br>        <span class="hljs-keyword">if</span> (t[p].l == t[p].r) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(id, t[p].l) &gt; <span class="hljs-built_in">f</span>(t[p].id, t[p].l)) t[p].id = id;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[id].k - a[t[p].id].k) &lt; eps) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(id, mid) &gt; <span class="hljs-built_in">f</span>(t[p].id, mid)) t[p].id = id;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[id].k &gt; a[t[p].id].k) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(id, mid) &gt; <span class="hljs-built_in">f</span>(t[p].id, mid)) <span class="hljs-built_in">change</span>(ls, l, r, t[p].id), t[p].id = id;<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">change</span>(rs, l, r, id);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(id, mid) &gt; <span class="hljs-built_in">f</span>(t[p].id, mid)) <span class="hljs-built_in">change</span>(rs, l, r, t[p].id), t[p].id = id;<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">change</span>(ls, l, r, id);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid) <span class="hljs-built_in">change</span>(ls, l, r, id);<br>    <span class="hljs-keyword">if</span> (r &gt; mid) <span class="hljs-built_in">change</span>(rs, l, r, id);<br>&#125;<br><span class="hljs-function">node <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    node ans = &#123;t[p].id, <span class="hljs-built_in">f</span>(t[p].id, x)&#125;;<br>    <span class="hljs-keyword">if</span> (t[p].l == t[p].r) <span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(x &lt;= mid ? <span class="hljs-built_in">query</span>(ls, x) : <span class="hljs-built_in">query</span>(rs, x), ans);<br>&#125;<br><span class="hljs-comment">//查询x=k处编号最大的线段（可修改node operator）</span><br><span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, x).id;<br><span class="hljs-comment">//插入线段</span><br><span class="hljs-keyword">if</span> (x0 &gt; x1) <span class="hljs-built_in">swap</span>(x0, x1), <span class="hljs-built_in">swap</span>(y0, y1);<br>a[++cnt].<span class="hljs-built_in">init</span>(x0, y0, x1, y1), <span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>, x0, x1, cnt);<br></code></pre></td></tr></table></figure><h3 id="主席树-静态区间第-k-小"><a href="#主席树-静态区间第-k-小" class="headerlink" title="主席树 (静态区间第 k 小)"></a>主席树 (静态区间第 k 小)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">segtree</span> &#123; <span class="hljs-type">int</span> ls, rs, sum; &#125; t[N &lt;&lt; <span class="hljs-number">5</span>];<br><span class="hljs-comment">// 初始化rt[0]=build(1,n)为离散化后的值域</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = ++tot;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    t[p].ls = <span class="hljs-built_in">build</span>(l, mid), t[p].rs = <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-comment">//插入rt[i]=update(x,1,n,rt[i-1])</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> o)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = ++tot;<br>    t[p] = t[o], t[p].sum++;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> dir;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= mid) t[p].ls = <span class="hljs-built_in">update</span>(x, l, mid, t[p].ls);<br>    <span class="hljs-keyword">else</span> t[p].rs = <span class="hljs-built_in">update</span>(x, mid + <span class="hljs-number">1</span>, r, t[p].rs);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">//查询query(rt[l-1],rt[r],1,n,k)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>, x = t[t[q].ls].sum - t[t[p].ls].sum;<br>    <span class="hljs-keyword">if</span> (k &lt;= x) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(t[p].ls, t[q].ls, l, mid, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(t[p].rs, t[q].rs, mid + <span class="hljs-number">1</span>, r, k - x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FHQ-平衡树"><a href="#FHQ-平衡树" class="headerlink" title="FHQ 平衡树"></a>FHQ 平衡树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> siz, ls, rs, prio, val;<br>&#125; t[N];<br><span class="hljs-type">int</span> n, m, tot, root;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newnode</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    t[++tot] = (node)&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">rand</span>(), k&#125;;<br>    <span class="hljs-keyword">return</span> tot;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; t[p].siz = t[t[p].ls].siz + t[t[p].rs].siz + <span class="hljs-number">1</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> p + q;<br>    <span class="hljs-keyword">if</span> (t[p].prio &lt; t[q].prio) &#123;<br>        t[p].rs = <span class="hljs-built_in">merge</span>(t[p].rs, q);<br>        <span class="hljs-built_in">refresh</span>(p);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    t[q].ls = <span class="hljs-built_in">merge</span>(p, t[q].ls);<br>    <span class="hljs-built_in">refresh</span>(q);<br>    <span class="hljs-keyword">return</span> q;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> &amp;p, <span class="hljs-type">int</span> &amp;q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!now) &#123; p = q = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-keyword">if</span> (t[now].val &lt;= k) p = now, <span class="hljs-built_in">split</span>(t[now].rs, k, t[now].rs, q);<br>    <span class="hljs-keyword">else</span> q = now, <span class="hljs-built_in">split</span>(t[now].ls, k, p, t[now].ls);<br>    <span class="hljs-built_in">refresh</span>(now);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (k &lt;= t[t[p].ls].siz) p = t[p].ls;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &gt; t[t[p].ls].siz + <span class="hljs-number">1</span>) k -= t[t[p].ls].siz + <span class="hljs-number">1</span>, p = t[p].rs;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//插入整数k</span><br><span class="hljs-built_in">split</span>(root, k, x, y);<br>root = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">merge</span>(x, <span class="hljs-built_in">newnode</span>(k)), y);<br><span class="hljs-comment">//删除整数k</span><br><span class="hljs-built_in">split</span>(root, k, x, z);<br><span class="hljs-built_in">split</span>(x, k - <span class="hljs-number">1</span>, x, y);<br>y = <span class="hljs-built_in">merge</span>(t[y].ls, t[y].rs);<br>root = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">merge</span>(x, y), z);<br><span class="hljs-comment">//查询k的排名</span><br><span class="hljs-built_in">split</span>(root, k - <span class="hljs-number">1</span>, x, y);<br>ans = t[x].siz + <span class="hljs-number">1</span>;<br>root = <span class="hljs-built_in">merge</span>(x, y);<br><span class="hljs-comment">//查询排名为k的数（如果不存在，则认为是排名小于k的最大数）</span><br>ans = t[<span class="hljs-built_in">kth</span>(root, k)].val;<br><span class="hljs-comment">//k的前驱</span><br><span class="hljs-built_in">split</span>(root, k - <span class="hljs-number">1</span>, x, y);<br>ans = t[<span class="hljs-built_in">kth</span>(x, t[x].siz)].val;<br>root = <span class="hljs-built_in">merge</span>(x, y);<br><span class="hljs-comment">//k的后继</span><br><span class="hljs-built_in">split</span>(root, k, x, y);<br>ans = t[<span class="hljs-built_in">kth</span>(y, <span class="hljs-number">1</span>)].val;<br>root = <span class="hljs-built_in">merge</span>(x, y);<br></code></pre></td></tr></table></figure><h3 id="文艺平衡树-splay"><a href="#文艺平衡树-splay" class="headerlink" title="文艺平衡树 (splay)"></a>文艺平衡树 (splay)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Splay</span> &#123;<br>    <span class="hljs-type">int</span> val[N], ch[N][<span class="hljs-number">2</span>], fa[N], tag[N], siz[N], root;<br>    <span class="hljs-built_in">Splay</span>() &#123; root = <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">chk</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> ch[fa[x]][<span class="hljs-number">1</span>] == x; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; siz[x] = siz[ch[x][<span class="hljs-number">0</span>]] + siz[ch[x][<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tag[x]) &#123;<br>            <span class="hljs-keyword">if</span> (ch[x][<span class="hljs-number">0</span>]) &#123;<br>                tag[ch[x][<span class="hljs-number">0</span>]] ^= <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">swap</span>(ch[ch[x][<span class="hljs-number">0</span>]][<span class="hljs-number">0</span>], ch[ch[x][<span class="hljs-number">0</span>]][<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ch[x][<span class="hljs-number">1</span>]) &#123;<br>                tag[ch[x][<span class="hljs-number">1</span>]] ^= <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">swap</span>(ch[ch[x][<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>], ch[ch[x][<span class="hljs-number">1</span>]][<span class="hljs-number">1</span>]);<br>            &#125;<br>            tag[x] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> now)</span> </span>&#123;<br>        <span class="hljs-type">int</span> f = fa[now], gf = fa[f], k = <span class="hljs-built_in">chk</span>(now), w = ch[now][k ^ <span class="hljs-number">1</span>];<br>        fa[w] = f, ch[f][k] = w;<br>        fa[now] = gf, ch[gf][<span class="hljs-built_in">chk</span>(f)] = now;<br>        fa[f] = now, ch[now][k ^ <span class="hljs-number">1</span>] = f;<br>        <span class="hljs-built_in">refresh</span>(f), <span class="hljs-built_in">refresh</span>(now);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> goal = <span class="hljs-number">0</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (fa[now] != goal) &#123;<br>            <span class="hljs-type">int</span> f = fa[now], gf = fa[f];<br>            <span class="hljs-keyword">if</span> (gf != goal) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">chk</span>(f) == <span class="hljs-built_in">chk</span>(now)) <span class="hljs-built_in">rotate</span>(f);<br>                <span class="hljs-keyword">else</span> <span class="hljs-built_in">rotate</span>(now);<br>            &#125;<br>            <span class="hljs-built_in">rotate</span>(now);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!goal) root = now;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> now = root;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">pushdown</span>(now);<br>            <span class="hljs-keyword">if</span> (ch[now][<span class="hljs-number">0</span>] &amp;&amp; siz[ch[now][<span class="hljs-number">0</span>]] &gt;= k) now = ch[now][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (siz[ch[now][<span class="hljs-number">0</span>]] + <span class="hljs-number">1</span> &lt; k) &#123;<br>                k -= siz[ch[now][<span class="hljs-number">0</span>]] + <span class="hljs-number">1</span>;<br>                now = ch[now][<span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> now;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        l = <span class="hljs-built_in">kth</span>(l), r = <span class="hljs-built_in">kth</span>(r + <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">splay</span>(l), <span class="hljs-built_in">splay</span>(r, l);<br>        <span class="hljs-keyword">return</span> ch[r][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">int</span> now = <span class="hljs-built_in">split</span>(l, r);<br>        tag[now] ^= <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">swap</span>(ch[now][<span class="hljs-number">0</span>], ch[now][<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> val[<span class="hljs-built_in">split</span>(x, x)]; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> f)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        val[mid] = a[mid]， fa[mid] = f;<br>        ch[mid][<span class="hljs-number">0</span>] = <span class="hljs-built_in">build</span>(l, mid - <span class="hljs-number">1</span>, mid);<br>        ch[mid][<span class="hljs-number">1</span>] = <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r, mid);<br>        <span class="hljs-built_in">refresh</span>(mid);<br>        <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>&#125; T;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    a[<span class="hljs-number">1</span>] = a[n + <span class="hljs-number">2</span>] = -INF;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n + <span class="hljs-number">1</span>; ++i) a[i] = i - <span class="hljs-number">1</span>;<br>    T.root = T.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">read</span>(), r = <span class="hljs-built_in">read</span>();<br>        T.<span class="hljs-built_in">reverse</span>(l, r);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-built_in">pintf</span>(<span class="hljs-string">&quot;%d &quot;</span>, T.<span class="hljs-built_in">query</span>(i));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">heap</span> &#123; <span class="hljs-type">int</span> val, fa, d, ch[<span class="hljs-number">2</span>]; &#125;t[N];<br><span class="hljs-comment">//dist大的视为左儿子，dist小的视为右儿子</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">rs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> t[x].ch[t[t[x].ch[<span class="hljs-number">1</span>]].d &lt; t[t[x].ch[<span class="hljs-number">0</span>]].d]; &#125;<br><span class="hljs-comment">//插入时直接merge一个新节点,O(log n)复杂度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!x || !y) <span class="hljs-keyword">return</span> x | y;<br>  <span class="hljs-keyword">if</span> (t[x].val &lt; t[y].val) <span class="hljs-built_in">swap</span>(x, y);<br>  <span class="hljs-type">int</span>&amp; rs_ref = <span class="hljs-built_in">rs</span>(x);<br>  rs_ref = <span class="hljs-built_in">merge</span>(rs_ref, y);<br>  t[rs_ref].fa = x;<br>  t[x].d = t[<span class="hljs-built_in">rs</span>(x)].d + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">//配合并查集维护是否在一个堆里（旧根指向新根），用数组记录是否被删除</span><br><span class="hljs-comment">//合并代码</span><br>x = <span class="hljs-built_in">find</span>(x), y = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span> (x != y) rt[x] = rt[y] = <span class="hljs-built_in">merge</span>(x, y);<br><span class="hljs-comment">//删除根</span><br>x = <span class="hljs-built_in">find</span>(x);<br>rt[x] = rt[t[x].ch[<span class="hljs-number">0</span>]] = rt[t[x].ch[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">merge</span>(t[x].ch[<span class="hljs-number">0</span>], t[x].ch[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">// 由于堆中的点会 find 到 x，所以 rt[x] 也要修改</span><br></code></pre></td></tr></table></figure><h3 id="ST-表"><a href="#ST-表" class="headerlink" title="ST 表"></a>ST 表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">//预处理log</span><br>  Logn[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, Logn[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt; maxn; i++) Logn[i] = Logn[i / <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 求静态区间[l,r]最大值/最小值/gcd</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) f[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">pre</span>();<br><span class="hljs-comment">//根据maxn确定logn=21,22..</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= logn; j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; i++)<br>  f[i][j] = <span class="hljs-built_in">max</span>(f[i][j - <span class="hljs-number">1</span>], f[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-type">int</span> s = Logn[y - x + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">max</span>(f[x][s], f[y - (<span class="hljs-number">1</span> &lt;&lt; s) + <span class="hljs-number">1</span>][s]));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x)&amp;(-x)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span> </span>&#123; <span class="hljs-keyword">for</span> (x &lt;= n; x += <span class="hljs-built_in">lowbit</span>(x)) c[x] += k; &#125; <span class="hljs-comment">//单点加</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;  <span class="hljs-comment">// a[1]..a[x]的和，用前缀和实现区间查询</span><br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (x &gt; <span class="hljs-number">0</span>; x -= <span class="hljs-built_in">lowbit</span>(x)) ans += c[x];<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果能把当前区间[l,r]的答案转移到与其相邻的区间，则可以实现O(n\sqrt(n))的复杂度</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  BLOCK_SIZE = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">pow</span>(n, <span class="hljs-number">0.5</span>)));<br>  <span class="hljs-comment">//l为第一关键字，r为第二关键字从小到大排序</span><br>  <span class="hljs-built_in">sort</span>(querys, querys + m);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-type">const</span> query &amp;q = querys[i];<br>    <span class="hljs-keyword">while</span> (l &gt; a[i].l) <span class="hljs-built_in">add</span>(c[--l]);<br>    <span class="hljs-keyword">while</span> (r &lt; a[i].r) <span class="hljs-built_in">add</span>(c[++r]);<br>    <span class="hljs-keyword">while</span> (l &lt; a[i].l) <span class="hljs-built_in">del</span>(c[l++]);<br>    <span class="hljs-keyword">while</span> (r &gt; a[i].r) <span class="hljs-built_in">del</span>(c[r--]);<br>    ans[q.id] = res;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    dep[u] = dep[fa[u]] + <span class="hljs-number">1</span>;<br>    siz[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mxson = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i; i = e[i].nxt) &#123;<br>        <span class="hljs-type">int</span> v = e[i].v;<br>        <span class="hljs-keyword">if</span> (v == fa[u]) <span class="hljs-keyword">continue</span>;<br>        fa[v] = u;<br>        <span class="hljs-built_in">dfs1</span>(v);<br>        siz[u] += siz[v]; <span class="hljs-comment">//子树大小</span><br>        <span class="hljs-keyword">if</span> (!son[u] || siz[v] &gt; mxson) &#123;<br>            son[u] = v; <span class="hljs-comment">//重儿子</span><br>            mxson = siz[v];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> topf)</span> </span>&#123;<br>    b[id[u] = ++dfn] = a[u];<br>    top[u] = topf; <span class="hljs-comment">//链顶</span><br>    <span class="hljs-keyword">if</span> (!son[u]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs2</span>(son[u], topf);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i; i = e[i].nxt) &#123;<br>        <span class="hljs-type">int</span> v = e[i].v;<br>        <span class="hljs-keyword">if</span> (v != fa[u] &amp;&amp; v != son[u]) <span class="hljs-built_in">dfs2</span>(v, v);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//树上路径+v</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tadd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (top[x] != top[y]) &#123;<br>        <span class="hljs-keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) <span class="hljs-built_in">swap</span>(x, y);<br>        <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, id[top[x]], id[x], v);<br>        x = fa[top[x]];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dep[x] &lt; dep[y]) <span class="hljs-built_in">swap</span>(x, y);<br>    <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, id[y], id[x], v);<br>&#125;<br><span class="hljs-comment">//树上路径求和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tquery</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (top[x] != top[y]) &#123;<br>        <span class="hljs-keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) <span class="hljs-built_in">swap</span>(x, y);<br>        ans += <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, id[top[x]], id[x]);<br>        x = fa[top[x]];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dep[x] &lt; dep[y]) <span class="hljs-built_in">swap</span>(x, y);<br>    ans += <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, id[y], id[x]);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">//子树内+v</span><br><span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, id[x], id[x] + siz[x] - <span class="hljs-number">1</span>, k);<br><span class="hljs-comment">//子树内求和</span><br><span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, id[x], id[x] + siz[x] - <span class="hljs-number">1</span>)；<br></code></pre></td></tr></table></figure><h3 id="原地堆化"><a href="#原地堆化" class="headerlink" title="原地堆化"></a>原地堆化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] h)</span> &#123; <span class="hljs-comment">// 从下往上遍历非叶子节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)  sink(h, i);<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(<span class="hljs-type">int</span>[] h, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> h.length;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span> &lt; n) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左儿子（因为起始下标为0所以+1）</span><br>        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; n &amp;&amp; h[j + <span class="hljs-number">1</span>] &gt; h[j]) j++; <span class="hljs-comment">// 跟左右儿子中较大的交换</span><br>        <span class="hljs-keyword">if</span> (h[i] &gt;= h[j])  <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 无法交换，递归结束</span><br>        swap(h, i, j), i = j; <span class="hljs-comment">// 交换后继续向下递归</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><h3 id="基本常数"><a href="#基本常数" class="headerlink" title="基本常数"></a>基本常数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">double</span> PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br></code></pre></td></tr></table></figure><h3 id="Point、Vector-类"><a href="#Point、Vector-类" class="headerlink" title="Point、Vector 类"></a>Point、Vector 类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br>&#125;;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> Point &amp;p) &#123;<span class="hljs-keyword">return</span> os &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p.y;&#125;<br><span class="hljs-keyword">typedef</span> Point Vector;<br><br>Vector <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vector &amp;p1, <span class="hljs-type">const</span> Vector &amp;p2) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(p<span class="hljs-number">1.</span>x + p<span class="hljs-number">2.</span>x, p<span class="hljs-number">1.</span>y + p<span class="hljs-number">2.</span>y);&#125;<br>Vector <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Vector &amp;p1, <span class="hljs-type">const</span> Vector &amp;p2) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(p<span class="hljs-number">1.</span>x - p<span class="hljs-number">2.</span>x, p<span class="hljs-number">1.</span>y - p<span class="hljs-number">2.</span>y);&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Point &amp;p1, <span class="hljs-type">const</span> Point &amp;p2) &#123;<span class="hljs-keyword">return</span> p<span class="hljs-number">1.</span>x == p<span class="hljs-number">2.</span>x &amp;&amp; p<span class="hljs-number">1.</span>y == p<span class="hljs-number">2.</span>y;&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point &amp;p1, <span class="hljs-type">const</span> Point &amp;p2) &#123;<span class="hljs-keyword">return</span> p<span class="hljs-number">1.</span>x &lt; p<span class="hljs-number">2.</span>x || (p<span class="hljs-number">1.</span>x == p<span class="hljs-number">2.</span>x &amp;&amp; p<span class="hljs-number">1.</span>y &lt; p<span class="hljs-number">2.</span>y);&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Cross</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector &amp;a, <span class="hljs-type">const</span> Vector &amp;b)</span> </span>&#123;<span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Dist</span><span class="hljs-params">(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> * (a.x - b.x) * (a.x - b.x) + <span class="hljs-number">1.0</span> * (a.y - b.y) * (a.y - b.y));<br>&#125;<br><span class="hljs-function">Vector <span class="hljs-title">Rotate</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector &amp;a, <span class="hljs-type">const</span> <span class="hljs-type">double</span> rad)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(a.x * <span class="hljs-built_in">cos</span>(rad) - a.y * <span class="hljs-built_in">sin</span>(rad), a.x * <span class="hljs-built_in">sin</span>(rad) + a.y * <span class="hljs-built_in">cos</span>(rad));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Dot</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector &amp;a, <span class="hljs-type">const</span> Vector &amp;b)</span> </span>&#123; <span class="hljs-keyword">return</span> a.x * b.x + a.y * b.y;&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Length</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector&amp; a)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> * <span class="hljs-built_in">Dot</span>(a, a)); &#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Angle</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector &amp;a, <span class="hljs-type">const</span> Vector &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">asin</span>(<span class="hljs-built_in">Cross</span>(a, b) / <span class="hljs-built_in">Length</span>(a) / <span class="hljs-built_in">Length</span>(b));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dcmp</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> a)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a) &lt;= eps) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Area</span><span class="hljs-params">(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b, <span class="hljs-type">const</span> Point &amp;c)</span> </span>&#123;<br>    Vector u = a - b, v = a - c;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">Cross</span>(u, v));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求凸包"><a href="#求凸包" class="headerlink" title="求凸包"></a>求凸包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;Point&gt; <span class="hljs-title">ConvexHell</span><span class="hljs-params">(vector&lt;Point&gt; &amp;p)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>());<br>    p.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>()), p.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">size</span>(), m = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;Point&gt; <span class="hljs-title">stk</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>        <span class="hljs-keyword">while</span> (m &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">Cross</span>(stk[m - <span class="hljs-number">1</span>] - stk[m - <span class="hljs-number">2</span>], p[i] - stk[m - <span class="hljs-number">2</span>]) &lt;= <span class="hljs-number">0</span>) m--;<br>        stk[m++] = p[i];<br>    &#125;<br>    <span class="hljs-type">int</span> k = m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>        <span class="hljs-keyword">while</span> (m &gt; k &amp;&amp; <span class="hljs-built_in">Cross</span>(stk[m - <span class="hljs-number">1</span>] - stk[m - <span class="hljs-number">2</span>], p[i] - stk[m - <span class="hljs-number">2</span>]) &lt;= <span class="hljs-number">0</span>) m--;<br>        stk[m++] = p[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) m--;<br>    stk.<span class="hljs-built_in">resize</span>(m);<br>    <span class="hljs-keyword">return</span> stk;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="旋转卡壳求凸包的直径"><a href="#旋转卡壳求凸包的直径" class="headerlink" title="旋转卡壳求凸包的直径"></a>旋转卡壳求凸包的直径</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameter2</span><span class="hljs-params">(vector&lt;Point&gt; &amp;points)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">ConvexHell</span>(points);<br>    <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Dist2</span>(p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>]);<br>    p.<span class="hljs-built_in">push_back</span>(p[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">0</span>, v = <span class="hljs-number">1</span>;u &lt; n;u++) &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> diff = <span class="hljs-built_in">Cross</span>(p[u + <span class="hljs-number">1</span>] - p[u], p[v + <span class="hljs-number">1</span>] - p[v]);<br>            <span class="hljs-keyword">if</span> (diff &lt;= <span class="hljs-number">0</span>) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">Dist2</span>(p[u], p[v]));<br>                <span class="hljs-keyword">if</span> (diff == <span class="hljs-number">0</span>) ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">Dist2</span>(p[u], p[v + <span class="hljs-number">1</span>]));<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            v = (v + <span class="hljs-number">1</span>) % n;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="最大流、最小割"><a href="#最大流、最小割" class="headerlink" title="最大流、最小割"></a>最大流、最小割</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MaxFlow</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Edge</span> &#123;<br>        <span class="hljs-type">int</span> to;<br>        T cap;<br>        _Edge(<span class="hljs-type">int</span> to, T cap) : <span class="hljs-built_in">to</span>(to), <span class="hljs-built_in">cap</span>(cap) &#123;&#125;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;_Edge&gt; e;<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; g;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; cur, h;<br><br>    <span class="hljs-built_in">MaxFlow</span>() &#123;&#125;<br>    <span class="hljs-built_in">MaxFlow</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">init</span>(n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        e.<span class="hljs-built_in">clear</span>();<br>        g.<span class="hljs-built_in">assign</span>(n, &#123;&#125;);<br>        cur.<span class="hljs-built_in">resize</span>(n);<br>        h.<span class="hljs-built_in">resize</span>(n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        h.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">-1</span>);<br>        std::queue&lt;<span class="hljs-type">int</span>&gt; que;<br>        h[s] = <span class="hljs-number">0</span>;<br>        que.<span class="hljs-built_in">push</span>(s);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> u = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : g[u]) &#123;<br>                <span class="hljs-keyword">auto</span> [v, c] = e[i];<br>                <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; h[v] == <span class="hljs-number">-1</span>) &#123;<br>                    h[v] = h[u] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (v == t) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                    que.<span class="hljs-built_in">push</span>(v);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> t, T f)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == t) &#123;<br>            <span class="hljs-keyword">return</span> f;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> r = f;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;i = cur[u]; i &lt; <span class="hljs-built_in">int</span>(g[u].<span class="hljs-built_in">size</span>()); ++i) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> j = g[u][i];<br>            <span class="hljs-keyword">auto</span> [v, c] = e[j];<br>            <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; h[v] == h[u] + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">dfs</span>(v, t, std::<span class="hljs-built_in">min</span>(r, c));<br>                e[j].cap -= a;<br>                e[j ^ <span class="hljs-number">1</span>].cap += a;<br>                r -= a;<br>                <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> f;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f - r;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, T c)</span> </span>&#123;<br>        g[u].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());<br>        e.<span class="hljs-built_in">emplace_back</span>(v, c);<br>        g[v].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());<br>        e.<span class="hljs-built_in">emplace_back</span>(u, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function">T <span class="hljs-title">flow</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        T ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>(s, t)) &#123;<br>            cur.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">0</span>);<br>            ans += <span class="hljs-built_in">dfs</span>(s, t, std::numeric_limits&lt;T&gt;::<span class="hljs-built_in">max</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">minCut</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            c[i] = (h[i] != <span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>        <span class="hljs-type">int</span> from;<br>        <span class="hljs-type">int</span> to;<br>        T cap;<br>        T flow;<br>    &#125;;<br>    <span class="hljs-function">std::vector&lt;Edge&gt; <span class="hljs-title">edges</span><span class="hljs-params">()</span> </span>&#123;<br>        std::vector&lt;Edge&gt; a;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; e.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>            Edge x;<br>            x.from = e[i + <span class="hljs-number">1</span>].to;<br>            x.to = e[i].to;<br>            x.cap = e[i].cap + e[i + <span class="hljs-number">1</span>].cap;<br>            x.flow = e[i + <span class="hljs-number">1</span>].cap;<br>            a.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MaxFlow</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Edge</span> &#123;<br>        <span class="hljs-type">int</span> to;<br>        T cap;<br>        _Edge(<span class="hljs-type">int</span> to, T cap) : <span class="hljs-built_in">to</span>(to), <span class="hljs-built_in">cap</span>(cap) &#123;&#125;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;_Edge&gt; e;<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; g;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; cur, h;<br><br>    <span class="hljs-built_in">MaxFlow</span>() &#123;&#125;<br>    <span class="hljs-built_in">MaxFlow</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">init</span>(n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        e.<span class="hljs-built_in">clear</span>();<br>        g.<span class="hljs-built_in">assign</span>(n, &#123;&#125;);<br>        cur.<span class="hljs-built_in">resize</span>(n);<br>        h.<span class="hljs-built_in">resize</span>(n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        h.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">-1</span>);<br>        std::queue&lt;<span class="hljs-type">int</span>&gt; que;<br>        h[s] = <span class="hljs-number">0</span>;<br>        que.<span class="hljs-built_in">push</span>(s);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> u = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : g[u]) &#123;<br>                <span class="hljs-keyword">auto</span> [v, c] = e[i];<br>                <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; h[v] == <span class="hljs-number">-1</span>) &#123;<br>                    h[v] = h[u] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (v == t) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                    que.<span class="hljs-built_in">push</span>(v);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> t, T f)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == t) &#123;<br>            <span class="hljs-keyword">return</span> f;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> r = f;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;i = cur[u]; i &lt; <span class="hljs-built_in">int</span>(g[u].<span class="hljs-built_in">size</span>()); ++i) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> j = g[u][i];<br>            <span class="hljs-keyword">auto</span> [v, c] = e[j];<br>            <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; h[v] == h[u] + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">dfs</span>(v, t, std::<span class="hljs-built_in">min</span>(r, c));<br>                e[j].cap -= a;<br>                e[j ^ <span class="hljs-number">1</span>].cap += a;<br>                r -= a;<br>                <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> f;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f - r;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, T c)</span> </span>&#123;<br>        g[u].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());<br>        e.<span class="hljs-built_in">emplace_back</span>(v, c);<br>        g[v].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());<br>        e.<span class="hljs-built_in">emplace_back</span>(u, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function">T <span class="hljs-title">flow</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        T ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>(s, t)) &#123;<br>            cur.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">0</span>);<br>            ans += <span class="hljs-built_in">dfs</span>(s, t, std::numeric_limits&lt;T&gt;::<span class="hljs-built_in">max</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">minCut</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            c[i] = (h[i] != <span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>        <span class="hljs-type">int</span> from;<br>        <span class="hljs-type">int</span> to;<br>        T cap;<br>        T flow;<br>    &#125;;<br>    <span class="hljs-function">std::vector&lt;Edge&gt; <span class="hljs-title">edges</span><span class="hljs-params">()</span> </span>&#123;<br>        std::vector&lt;Edge&gt; a;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; e.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>            Edge x;<br>            x.from = e[i + <span class="hljs-number">1</span>].to;<br>            x.to = e[i].to;<br>            x.cap = e[i].cap + e[i + <span class="hljs-number">1</span>].cap;<br>            x.flow = e[i + <span class="hljs-number">1</span>].cap;<br>            a.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="tarjan-ecc-缩点，求桥"><a href="#tarjan-ecc-缩点，求桥" class="headerlink" title="tarjan ecc 缩点，求桥"></a>tarjan ecc 缩点，求桥</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>    <span class="hljs-type">int</span> v, ne;<br>&#125; e[M];<br><span class="hljs-type">int</span> h[N], idx = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> dfn[N], low[N], tot;<br>stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><span class="hljs-type">int</span> dcc[N], cnt;<br><span class="hljs-type">int</span> bri[M], d[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[++idx].v = b;<br>    e[idx].ne = h[a];<br>    h[a] = idx;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> in_edg)</span></span><br><span class="hljs-function"></span>&#123;<br>    dfn[x] = low[x] = ++tot;<br>    stk.<span class="hljs-built_in">push</span>(x);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; i; i = e[i].ne)<br>    &#123;<br>        <span class="hljs-type">int</span> y = e[i].v;<br>        <span class="hljs-keyword">if</span> (!dfn[y])<br>        &#123;<br>            <span class="hljs-built_in">tarjan</span>(y, i);<br>            low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);<br>            <span class="hljs-keyword">if</span> (low[y] &gt; dfn[x])<br>                bri[i] = bri[i ^ <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != (in_edg ^ <span class="hljs-number">1</span>))<br>            low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dfn[x] == low[x])<br>    &#123;<br>        ++cnt;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> y = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            dcc[y] = cnt;<br>            <span class="hljs-keyword">if</span> (y == x)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tarjan-vcc-缩点，求割点"><a href="#tarjan-vcc-缩点，求割点" class="headerlink" title="tarjan vcc 缩点，求割点"></a>tarjan vcc 缩点，求割点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">int</span>&gt; edge[MAXN];<br>vector&lt;<span class="hljs-type">int</span>&gt; vcc[MAXN];<br>vector&lt;<span class="hljs-type">int</span>&gt; vcc_edge[MAXN];<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(MAXN)</span></span>;<br><span class="hljs-type">int</span> dfn[MAXN], low[MAXN];<br><span class="hljs-type">bool</span> cut[MAXN];<br><span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">0</span>;<br>stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    dfn[u] = low[u] = ++tot;<br>    stk.<span class="hljs-built_in">emplace</span>(u);<br>    <span class="hljs-keyword">if</span> (edge[u].<span class="hljs-built_in">empty</span>())&#123;<br>        vcc[++cnt].<span class="hljs-built_in">emplace_back</span>(u);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : edge[u])&#123;<br>        <span class="hljs-keyword">if</span> (!dfn[it])&#123;<br>            <span class="hljs-built_in">tarjan</span>(it);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u],low[it]);<br>            <span class="hljs-keyword">if</span> (low[it] &gt;= dfn[u])&#123;<br>                cut[u] = <span class="hljs-literal">true</span>;<br>            &#125;<br>            cnt++;<br>            <span class="hljs-type">int</span> y;<br>            <span class="hljs-keyword">do</span><br>            &#123;<br>                y = stk.<span class="hljs-built_in">top</span>();<br>                vcc[cnt].<span class="hljs-built_in">emplace_back</span>(y);<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">while</span> (y == it);<br><br>            vcc[cnt].<span class="hljs-built_in">emplace_back</span>(u);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            low[u] = <span class="hljs-built_in">min</span>(low[u],dfn[it]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tarjan-scc-缩点，求强连通分量"><a href="#tarjan-scc-缩点，求强连通分量" class="headerlink" title="tarjan scc 缩点，求强连通分量"></a>tarjan scc 缩点，求强连通分量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; edge[N];<br><span class="hljs-type">int</span> dfn[N], low[N], top = <span class="hljs-number">0</span>, stk[N];<br><span class="hljs-type">bool</span> instk[N];<br><span class="hljs-type">int</span> timer = <span class="hljs-number">0</span>, scc_cnt = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//无论对于一个有向图还是无向图来说，缩点后的结果一定是一个森林</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    low[u] = dfn[u] = ++timer;<br>    stk[++top] = u;<br>    instk[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : edge[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!dfn[v])<br>        &#123;<br>            <span class="hljs-built_in">tarjan</span>(v);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[v]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instk[v])<br>        &#123;<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[v]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dfn[u] == low[u])<br>    &#123;<br>        scc_cnt ++;<br>        scc[u] = scc_cnt;<br>        instk[u] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span> (stk[top] != u) &#123;<br>            scc[stk[top]] = scc_cnt;<br>            instk[stk[top--]] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        top --;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (!isPrime[i])&#123;<br>        prime[++cnt] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++)&#123;<br>        isPrime[i * prime[j]] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">exgcd</span><span class="hljs-params">(T a, T b, T &amp;x, T &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!b) &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    T d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= a / b * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">mul</span><span class="hljs-params">(T a, T b, T mod)</span> </span>&#123;<br>    a = (a % mod + mod) % mod;<br>    b = (b % mod + mod) % mod;<br>    T ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((b &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>            ans = (ans + a) % mod;<br>        &#125;<br>        a = (a + a) % mod;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">excrt</span><span class="hljs-params">(vector&lt;T&gt; &amp;m, vector&lt;T&gt; &amp;r)</span> </span>&#123;<br>    T tail = <span class="hljs-number">0</span>, lcm = <span class="hljs-number">1</span>, tmp, b, c, x0, x, y, d;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m.<span class="hljs-built_in">size</span>();i++) &#123;<br>        b = m[i]; c = ((r[i] - tail) % b + b) % b;<br>        d = <span class="hljs-built_in">exgcd</span>(lcm, b, x, y);<br>        <span class="hljs-keyword">if</span> (c % d != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        x0 = <span class="hljs-built_in">mul</span>(x, c / d, b / d);<br>        tmp = lcm * (b / d);<br>        tail = (tail + <span class="hljs-built_in">mul</span>(x0, lcm, tmp)) % tmp;<br>        lcm = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tail;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="exgcd"><a href="#exgcd" class="headerlink" title="exgcd"></a>exgcd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function">T <span class="hljs-title">sign</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : (a &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function">T <span class="hljs-title">ceil</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;a, <span class="hljs-type">const</span> T &amp;b)</span> </span>&#123;<br>    T A = <span class="hljs-built_in">abs</span>(a), B = <span class="hljs-built_in">abs</span>(b);<br>    <span class="hljs-built_in">assert</span>(b != <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sign</span>(a) * <span class="hljs-built_in">sign</span>(b) &gt; <span class="hljs-number">0</span> ? (A + B - <span class="hljs-number">1</span>) / B : -A / B;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">exgcd</span><span class="hljs-params">(T a, T b, T &amp;x, T &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!b) &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    T d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= a / b * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(T a, T b, T c)</span> </span>&#123;<br>    T x, y, d = <span class="hljs-built_in">exgcd</span>(a, b, x, y);<br>    <span class="hljs-keyword">if</span> (c % d != <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Impossible&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    x *= c / d, y *= c / d;<br>    T p = b / d, q = a / d, k;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>        k = <span class="hljs-built_in">ceil</span>(<span class="hljs-number">1</span> - x, p);<br>        x += p * k;<br>        y -= q * k;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//将x提高到最小正整数</span><br>        k = (x - <span class="hljs-number">1</span>) / p;<br>        x -= p * k; <span class="hljs-comment">//将x降低到最小正整数</span><br>        y += q * k;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (y &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//有正整数解</span><br>        cout &lt;&lt; (y - <span class="hljs-number">1</span>) / q + <span class="hljs-number">1</span> &lt;&lt; endl; <span class="hljs-comment">//将y减到1的方案数即为解的个数</span><br>        cout &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">//当前的x即为最小正整数x</span><br>        cout &lt;&lt; (y - <span class="hljs-number">1</span>) % q + <span class="hljs-number">1</span> &lt;&lt; endl; <span class="hljs-comment">//将y取到最小正整数</span><br>        cout &lt;&lt; x + (y - <span class="hljs-number">1</span>) / q * p &lt;&lt; endl; <span class="hljs-comment">//将x提升到最大</span><br>        cout &lt;&lt; y &lt;&lt; endl; <span class="hljs-comment">//特解即为y最大值</span><br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//无整数解</span><br>        cout &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">//当前的x即为最小的正整数x</span><br>        cout &lt;&lt; y + <span class="hljs-function">q * <span class="hljs-title">ceil</span><span class="hljs-params">(<span class="hljs-number">1</span> - y, q)</span> &lt;&lt; endl</span>; <span class="hljs-comment">//将y提高到正整数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="exlucas"><a href="#exlucas" class="headerlink" title="exlucas"></a>exlucas</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">qpow</span><span class="hljs-params">(T a, T b, T mod)</span> </span>&#123;<br>    T ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (;b;b &gt;&gt;= <span class="hljs-number">1</span>, a = a * a % mod)<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) ans = ans * a % mod;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">exgcd</span><span class="hljs-params">(T a, T b, T &amp;x, T &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!b) &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    T d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= a / b * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">mul</span><span class="hljs-params">(T a, T b, T mod)</span> </span>&#123;<br>    a = (a % mod + mod) % mod;<br>    b = (b % mod + mod) % mod;<br>    T ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((b &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>            ans = (ans + a) % mod;<br>        &#125;<br>        a = (a + a) % mod;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">excrt</span><span class="hljs-params">(vector&lt;T&gt; &amp;m, vector&lt;T&gt; &amp;r)</span> </span>&#123;<br>    T tail = <span class="hljs-number">0</span>, lcm = <span class="hljs-number">1</span>, tmp, b, c, x0, x, y, d;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m.<span class="hljs-built_in">size</span>();i++) &#123;<br>        b = m[i]; c = ((r[i] - tail) % b + b) % b;<br>        d = <span class="hljs-built_in">exgcd</span>(lcm, b, x, y);<br>        <span class="hljs-keyword">if</span> (c % d != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        x0 = <span class="hljs-built_in">mul</span>(x, c / d, b / d);<br>        tmp = lcm * (b / d);<br>        tail = (tail + <span class="hljs-built_in">mul</span>(x0, lcm, tmp)) % tmp;<br>        lcm = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tail;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">4e4</span> + <span class="hljs-number">10</span>;<br>i64 fact[MAXN];<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">inv</span><span class="hljs-params">(T a, T mod)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(a, mod - <span class="hljs-number">2</span>, mod);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">C</span><span class="hljs-params">(T n, T m, T mod)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> fact[n] * <span class="hljs-built_in">inv</span>(fact[m], mod) % mod * <span class="hljs-built_in">inv</span>(fact[n - m], mod) % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">lucas</span><span class="hljs-params">(T n, T m, T mod)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lucas</span>(n / mod, m / mod, mod) * <span class="hljs-built_in">C</span>(n % mod, m % mod, mod) % mod;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-7</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">dcmp</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a - b) &lt; eps) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> a &gt; b ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//最普通的高斯消元</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gauss</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt; &amp;matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>        <span class="hljs-type">int</span> r = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;j &lt; n;j ++)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dcmp</span>(<span class="hljs-built_in">fabs</span>(matrix[r][i]), <span class="hljs-built_in">fabs</span>(matrix[j][i])) == <span class="hljs-number">-1</span>) r = j;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dcmp</span>(matrix[r][i], <span class="hljs-number">0.0</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No Solution\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i != r) <span class="hljs-built_in">swap</span>(matrix[i], matrix[r]);<br>        <span class="hljs-type">double</span> div = matrix[i][i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i;j &lt;= n;j++) matrix[i][j] /= div;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;j &lt; n;j++) &#123;<br>            div = matrix[j][i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i;k &lt;= n;k++) matrix[j][k] -= matrix[i][k] * div;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>    ans[n - <span class="hljs-number">1</span>] = matrix[n - <span class="hljs-number">1</span>][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>        ans[i] = matrix[i][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;j &lt; n;j++) ans[i] -= matrix[i][j] * ans[j];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, ans[i]);<br>&#125;<br><span class="hljs-comment">//区分无解，多解和唯一解</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gauss2</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt; &amp;matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>        <span class="hljs-type">int</span> mx = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">fabs</span>(matrix[j][j]) &gt;= eps) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dcmp</span>(<span class="hljs-built_in">fabs</span>(matrix[j][i]), <span class="hljs-built_in">fabs</span>(matrix[mx][i])) == <span class="hljs-number">1</span>) mx = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mx != i) <span class="hljs-built_in">swap</span>(matrix[mx], matrix[i]);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(matrix[i][i]) &gt;= eps) &#123;<br>            <span class="hljs-type">double</span> div = matrix[i][i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i;j &lt;= n;j++) matrix[i][j] /= div;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">continue</span>;<br>                div = matrix[j][i] / matrix[i][i];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i;k &lt;= n;k++) matrix[j][k] -= div * matrix[i][k];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">fabs</span>(matrix[i][i]) &lt; eps) &amp;&amp; (<span class="hljs-built_in">fabs</span>(matrix[i][n]) &gt;= eps)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(matrix[i][i]) &lt; eps) flag = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x%d=%.2lf\n&quot;</span>, i + <span class="hljs-number">1</span>, matrix[i][n]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 异或方程组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Gauss3</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>        <span class="hljs-type">int</span> is = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &lt; i &amp;&amp; matrix[j][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (matrix[j][i] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i], matrix[j]);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (matrix[i][i] != <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (matrix[j][i] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i;k &lt;= n;k++) matrix[j][k] ^= matrix[i][k];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//同余方程组（要求mod相同）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Gauss4</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &lt; i &amp;&amp; matrix[j][j] != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (matrix[j][i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">swap</span>(matrix[j], matrix[i]);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (matrix[i][i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == j || matrix[j][i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> gcdNum = __gcd(matrix[i][i], matrix[j][i]);<br>            <span class="hljs-type">int</span> a = matrix[i][i] / gcdNum, b = matrix[j][i] / gcdNum;<br>            <span class="hljs-keyword">if</span> (j &lt; i &amp;&amp; matrix[j][j] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j;k &lt; i;k++) matrix[j][k] = (matrix[j][k] * a) % mod;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i;k &lt;= n + <span class="hljs-number">1</span>;k++)<br>                matrix[j][k] = (matrix[j][k] * a % mod - matrix[i][k] * b % mod + mod) % mod;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1E7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> P = <span class="hljs-number">1000003</span>;<br><br><span class="hljs-type">bool</span> isprime[N + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> phi[N + <span class="hljs-number">1</span>];<br>std::vector&lt;<span class="hljs-type">int</span>&gt; primes;<br><br>std::<span class="hljs-built_in">fill</span>(isprime + <span class="hljs-number">2</span>, isprime + N + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++) &#123;<br>    <span class="hljs-keyword">if</span> (isprime[i]) &#123;<br>        primes.<span class="hljs-built_in">push_back</span>(i);<br>        phi[i] = i - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : primes) &#123;<br>        <span class="hljs-keyword">if</span> (i * p &gt; N) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        isprime[i * p] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (i % p == <span class="hljs-number">0</span>) &#123;<br>            phi[i * p] = phi[i] * p;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        phi[i * p] = phi[i] * (p - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 求单个数的欧拉函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>                n /= i;<br>            &#125;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) &#123;<br>        res = res / n * (n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">uint64_t</span> p[<span class="hljs-number">52</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">51</span>; ~i; i--) &#123;<br>        <span class="hljs-keyword">if</span> (!(x &gt;&gt; i)) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (!p[i]) &#123;<br>            p[i] = x;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        x ^= p[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 求异或和最大</span><br><span class="hljs-type">uint64_t</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">51</span>; ~i; i--)<br>    ans = <span class="hljs-built_in">max</span>(ans, ans ^ p[i]);<br>cout &lt;&lt; ans &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    lsh[i] = a[i] = <span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">sort</span>(lsh + <span class="hljs-number">1</span>, lsh + n + <span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> m = <span class="hljs-built_in">unique</span>(lsh + <span class="hljs-number">1</span>, lsh + n + <span class="hljs-number">1</span>) - lsh - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    a[i] = <span class="hljs-built_in">lower_bound</span>(lsh + <span class="hljs-number">1</span>, lsh + m + <span class="hljs-number">1</span>, a[i]) - lsh;<br><br></code></pre></td></tr></table></figure><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">C</span>(n,m)%<span class="hljs-number">2</span> = (n&amp;m)==m<br>约瑟夫问题：<br><span class="hljs-built_in">F</span>(n,m) = 有 n 个人 (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,..,n−<span class="hljs-number">1</span>)，每次杀掉编号为(x + m) % n的人，最终的幸存者。<br><span class="hljs-built_in">F</span>(n,m) = (<span class="hljs-built_in">F</span>(n − <span class="hljs-number">1</span>, m) + m) % n<br></code></pre></td></tr></table></figure><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\(', '\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
    
    
    <categories>
      
      <category>做题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣757.设置交集大小至少为2</title>
    <link href="/2025/11/21/%E5%8A%9B%E6%89%A3757-%E8%AE%BE%E7%BD%AE%E4%BA%A4%E9%9B%86%E5%A4%A7%E5%B0%8F%E8%87%B3%E5%B0%91%E4%B8%BA2/"/>
    <url>/2025/11/21/%E5%8A%9B%E6%89%A3757-%E8%AE%BE%E7%BD%AE%E4%BA%A4%E9%9B%86%E5%A4%A7%E5%B0%8F%E8%87%B3%E5%B0%91%E4%B8%BA2/</url>
    
    <content type="html"><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给定 $n (1\le n\le 10^5)$ 个闭区间 $[l_i, r_i] (1 \le l_i, r_i \le 10^8)$。需要构造一个整数集合 $S$，使得对每个区间 $[l_i, r_i]$，其中至少有 <strong>两个不同的整数</strong> 属于集合 $S$。求集合 $S$ 的最小可能大小。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>比较容易想到的是按照左端点升序排序，从后往前遍历，尽可能选靠前的位置，增大被多个区间共用的可能。然后考虑左端点相同的情况如何处理：比如 $[1,2]$ 和 $[1,5]$，发现在 $[3,5]$ 区间里的已有的点没有贡献，因为即便 $[3,5]$ 里有一个或者两个点，把 $[1,5]$ 满足了，$[1,2]$ 还是要放两个；反过来 $[1,2]$ 满足了则 $[1,5]$ 一定满足，所以应该将区间 $[l_i, r_i]$ 按照左端点升序，右端点降序排序。如下图所示：</p><img src="/2025/11/21/%E5%8A%9B%E6%89%A3757-%E8%AE%BE%E7%BD%AE%E4%BA%A4%E9%9B%86%E5%A4%A7%E5%B0%8F%E8%87%B3%E5%B0%91%E4%B8%BA2/image.png" class="" title="排序后的区间"><p>排序后，从后往前遍历每个区间。首先贪心地选取最后一个区间的 $l_n, l_n+1$ 两个位置，并记录为 $L, R$。向前遍历到倒数第二个区间时，检查:</p><ul><li>$L, R$ 都在 $[l_{n-1}, r_{n-1}]$ 范围内，跳过该区间；</li><li>只有 $L$ 在 $[l_{n-1}, r_{n-1}]$ 范围内，$R \gets L, L \gets l_{n-1}$，答案增加 1；</li><li>两者都不在范围内，$L&#x3D;l_{n-1}, R&#x3D;l_{n-1}+1$，答案增加 2。</li></ul><p>以此类推，$O(n)$ 时间复杂度得到答案。</p><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
    
    
    <categories>
      
      <category>做题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>题解</tag>
      
      <tag>贪心</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>30分钟写一个天气查询网站</title>
    <link href="/2025/11/21/30%E5%88%86%E9%92%9F%E5%86%99%E4%B8%80%E4%B8%AA%E5%A4%A9%E6%B0%94%E6%9F%A5%E8%AF%A2%E7%BD%91%E7%AB%99/"/>
    <url>/2025/11/21/30%E5%88%86%E9%92%9F%E5%86%99%E4%B8%80%E4%B8%AA%E5%A4%A9%E6%B0%94%E6%9F%A5%E8%AF%A2%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>本文使用 CGI 编写一个极其简单的天气查询网站，只需要实现一个 <code>index.html</code> 页面和一个 <code>weather.py</code> 脚本（调用高德天气 API）即可。CGI 是一种相对原始的协议，服务器接收形如 <code>&lt;path/to/script?parameters&gt;</code> 的请求时，每次创建一个新的进程运行该脚本响应。因为每次请求都要创建新进程，开销较大且资源浪费，因此在现代 Web 开发中已较少使用。CGI 的现代替代方案是 WSGI，它允许应用程序作为一个长期运行的进程或线程存在于内存中，服务器可以直接调用内存中的代码，因而提高了性能，Flask, Django 等主流 Web 框架都基于 WSGI 而非 CGI。本项目目录结构如图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">weather-info/<br>└─cgi-bin/<br>    └─weather.py<br>└─index.html<br></code></pre></td></tr></table></figure><p>首先把前端页面写出来：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Weather Information<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 查询部分 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;city_input&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Show<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 展示部分，后续用 JS 替换掉 span 里的内容 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>City<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Weather<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;weather&quot;</span>&gt;</span>晴<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Temperature<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temperature&quot;</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> ℃ <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Humidity<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;humidity&quot;</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>%<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>用 <code>python -m http.server --cgi 8000</code> 启动 CGI 服务器，在 <code>localhost:8000</code> 确认前端的效果无误后，接下来的任务是：</p><ol><li>取出 <code>&lt;input&gt;</code> 输入的 <code>city_input</code>，使用 CGI 协议启动后端脚本，查询对应城市并接收脚本返回的 JSON 信息，渲染到界面上。这一部分用 Javascript 写在 <code>&lt;script&gt;</code> 标签里。</li><li>后端 Python 脚本接收城市名参数，调用高德地图天气 API，整理 JSON 发回前端页面。</li></ol><p>我们先写后端脚本 <code>cgi-bin/weather.py</code>。根据高德开放平台的文档，注册账号，创建应用，可以拿到自己的 <code>API_KEY</code> 以及 API 链接 <code>https://restapi.amap.com/v3/weather/weatherInfo?city=&#123;adcode&#125;&amp;key=&#123;key&#125;</code>。</p><p>注意到 API 不支持直接按照城市名称查询，而是需要查询城市对应的 adcode。经过寻找，在 <a href="https://lbs.amap.com/api/webservice/download">这个页面</a> 下载城市编码表。表格给定了城市对应的 adcode，如图所示。我们只需实现一个 <code>get_adcode(city_name)</code> 函数，读取 xlsx 文件，查表并返回 adcode 即可。</p><img src="/2025/11/21/30%E5%88%86%E9%92%9F%E5%86%99%E4%B8%80%E4%B8%AA%E5%A4%A9%E6%B0%94%E6%9F%A5%E8%AF%A2%E7%BD%91%E7%AB%99/adcode_table.png" class="" title="城市编码表"><p>我们把城市编码表 AMap_adcode_citycode.xlsx 放在 weather.py 的同级目录下，即 <code>cgi-bin/AMap_adcode_citycode.xlsx</code>，则 <code>get_adcode(city_name)</code> 如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> openyxl <span class="hljs-keyword">import</span> load_workbook<br><span class="hljs-keyword">import</span> pathlib<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_adcode</span>(<span class="hljs-params">city_name: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-comment"># 利用 pathlib 从 weather.py 的位置推出 xlsx 的位置</span><br>    script_dir = pathlib.Path(__file__).resolve().parent<br>    file_name = <span class="hljs-string">&#x27;AMap_adcode_citycode.xlsx&#x27;</span><br>    file_path = <span class="hljs-built_in">str</span>(script_dir / file_name)<br><br>    <span class="hljs-comment"># 加载 excel 文件</span><br>    workbook = load_workbook(file_path)<br>    sheet = workbook.active<br><br>    <span class="hljs-comment"># 遍历每一行（第一行为表头，从第二行开始）</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> sheet.iter_rows(min_row=<span class="hljs-number">2</span>):<br>        current_city = <span class="hljs-built_in">str</span>(row[<span class="hljs-number">0</span>].value).strip(<br>        ) <span class="hljs-keyword">if</span> row[<span class="hljs-number">0</span>].value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span><br><br>        <span class="hljs-comment"># current_city 均为行政区划全名，这里 current_city 包含 city_name 即认为匹配</span><br>        <span class="hljs-keyword">if</span> city_name.strip() <span class="hljs-keyword">in</span> current_city:<br>            arcode_value = row[<span class="hljs-number">1</span>].value<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(arcode_value).strip()<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>构建了城市名对 adcode 的映射后，我们先固定 <code>city_name</code>，查询一下吧：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py">city_name = <span class="hljs-string">&quot;东城区&quot;</span><br>API_KEY = <span class="hljs-string">&quot;your/api/key&quot;</span><br><br>api = <span class="hljs-string">&quot;https://restapi.amap.com/v3/weather/weatherInfo?city=&#123;adcode&#125;&amp;key=&#123;key&#125;&quot;</span><br>url = api.<span class="hljs-built_in">format</span>(adcode=get_adcode(city_name), key=API_KEY)<br><br>response = requests.get(url)<br>data = response.json()<br><span class="hljs-built_in">print</span>(data)<br></code></pre></td></tr></table></figure><p>打印出来的结果是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;OK&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;infocode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10000&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;lives&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;province&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;北京&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;东城区&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;adcode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;110101&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;weather&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;晴&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;temperature&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;13&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;winddirection&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;南&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;windpower&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;≤3&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;humidity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;19&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;reporttime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2025-11-21 11:07:39&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;temperature_float&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;13.0&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;humidity_float&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;19.0&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这就是完整的 JSON 返回值，我们不需要这么多信息，这里只取出城市、天气、温度、湿度打包发回前端：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py">responseData = &#123;<br>    <span class="hljs-string">&quot;city&quot;</span>: data[<span class="hljs-string">&quot;lives&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;city&quot;</span>], <span class="hljs-comment"># 注意加中间的 [0]，&quot;lives&quot; 是一个列表</span><br>    <span class="hljs-string">&quot;weather&quot;</span>: data[<span class="hljs-string">&quot;lives&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;weather&quot;</span>],<br>    <span class="hljs-string">&quot;temperature&quot;</span>: data[<span class="hljs-string">&quot;lives&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;temperature&quot;</span>],<br>    <span class="hljs-string">&quot;humidity&quot;</span>: data[<span class="hljs-string">&quot;lives&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;humidity&quot;</span>]<br>&#125;<br>jsonText = json.dumps(responseData, indent=<span class="hljs-number">4</span>)<br><span class="hljs-comment"># CGI 协议中，服务器将脚本的全部标准输出作为返回值，print 了就是发送了</span><br><span class="hljs-comment"># 因此需要特别注意输出格式，e.g. 先输出 header，不要输出调试语句等</span><br><span class="hljs-comment"># ——记得注释掉上上个代码块的 print(data)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Content-type: text/json\n&quot;</span>)<br><span class="hljs-built_in">print</span>(jsonText)<br></code></pre></td></tr></table></figure><p>回到前端，我们编写前后端交互和渲染页面的部分，主要实现 <code>showWeatherInfo()</code> 和 <code>updatePage()</code> 两个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>(); <span class="hljs-comment">// 创建 request 对象，readyState == 0</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showWeatherInfo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 查询天气信息，绑定到 button 的 onclick 事件</span><br>  <span class="hljs-keyword">var</span> city_input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;city_input&quot;</span>).<span class="hljs-property">value</span>;<br>  <span class="hljs-comment">// 通过查询参数传递城市名称，后端使用 FieldStorage 获取参数</span><br>  <span class="hljs-keyword">var</span> url = <span class="hljs-built_in">encodeURI</span>(<span class="hljs-string">&quot;/cgi-bin/weather.py?city=&quot;</span> + city_input);<br>  request.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>); <span class="hljs-comment">// open() 初始化 request 对象，readyState == 1</span><br>  request.<span class="hljs-property">onreadystatechange</span> = updatePage; <span class="hljs-comment">// updatePage 绑定到 onreadystatechange 事件，每次 readyState 改变都自动调用</span><br>  request.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 发送请求，收到 header 后 readyState == 2，接受 body 中 readyState == 3</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updatePage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (request.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-comment">// 完全接受后 readyState == 4，可以安全使用</span><br>    <span class="hljs-keyword">if</span> (request.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123;<br>      <span class="hljs-keyword">var</span> replyDoc = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(request.<span class="hljs-property">responseText</span>);<br>      <span class="hljs-comment">// city</span><br>      <span class="hljs-keyword">var</span> city = replyDoc.<span class="hljs-property">city</span>;<br>      <span class="hljs-keyword">var</span> cityElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;city&quot;</span>);<br>      cityElement.<span class="hljs-title function_">removeChild</span>(cityElement.<span class="hljs-property">firstChild</span>);<br>      cityElement.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(city));<br>      <span class="hljs-comment">// weather</span><br>      <span class="hljs-keyword">var</span> weather = replyDoc.<span class="hljs-property">weather</span>;<br>      <span class="hljs-keyword">var</span> weatherElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;weather&quot;</span>);<br>      weatherElement.<span class="hljs-title function_">removeChild</span>(weatherElement.<span class="hljs-property">firstChild</span>);<br>      weatherElement.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(weather));<br>      <span class="hljs-comment">// temperature</span><br>      <span class="hljs-keyword">var</span> temperature = replyDoc.<span class="hljs-property">temperature</span>;<br>      <span class="hljs-keyword">var</span> temperatureElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;temperature&quot;</span>);<br>      temperatureElement.<span class="hljs-title function_">removeChild</span>(temperatureElement.<span class="hljs-property">firstChild</span>);<br>      temperatureElement.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(temperature));<br>      <span class="hljs-comment">// humidity</span><br>      <span class="hljs-keyword">var</span> humidity = replyDoc.<span class="hljs-property">humidity</span>;<br>      <span class="hljs-keyword">var</span> humidityElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;humidity&quot;</span>);<br>      humidityElement.<span class="hljs-title function_">removeChild</span>(humidityElement.<span class="hljs-property">firstChild</span>);<br>      humidityElement.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(humidity));<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后把 <code>showWeatherInfo()</code> 绑定到 <code>&lt;button&gt;</code> 上，即 <code>&lt;button type=&quot;submit&quot; name=&quot;submit&quot; onclick=&quot;showWeatherInfo()&quot;&gt;Show&lt;/button&gt;</code>。这样，当我们点击按钮后，输入框中的文本 <code>东城区</code> 将会被以 <code>GET /cgi-bin/weather.py?city=东城区</code> 形式发往后端（如前所述，开启一个新的进程运行 weather.py 脚本，脚本通过 FieldStorage 接收参数并且打印到标准输出）。</p><p>现在，我们只需要补全 weather.py，让它拿到参数 <code>city_name</code> 即可——把 <code>city_name = &#39;东城区&#39;</code> 替换为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">form = cgi.FieldStorage()<br>city_name = form.getvalue(<span class="hljs-string">&#x27;city&#x27;</span>, <span class="hljs-string">&#x27;东城区&#x27;</span>)<br></code></pre></td></tr></table></figure><p>一个简单的天气查询网站就开发完成了，效果如图所示：</p><img src="/2025/11/21/30%E5%88%86%E9%92%9F%E5%86%99%E4%B8%80%E4%B8%AA%E5%A4%A9%E6%B0%94%E6%9F%A5%E8%AF%A2%E7%BD%91%E7%AB%99/weather.png" class="" title="查询结果">]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
